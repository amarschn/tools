"""
Rotor unbalance and ISO 1940-1 balancing limits calculator.
Useful for sizing high-speed rotating machinery.
"""

from __future__ import annotations

import math
from typing import Dict, Any, List

ISO_GRADES = {
    "G0.4": {"grade_mm_s": 0.4, "description": "Spindles, gyroscopes, precision grinders"},
    "G1.0": {"grade_mm_s": 1.0, "description": "Small electric motor armatures, tape recorder drives"},
    "G2.5": {"grade_mm_s": 2.5, "description": "Gas and steam turbines, medium electric motors, computer memory drums"},
    "G6.3": {"grade_mm_s": 6.3, "description": "Pump impellers, fans, general machine parts"},
    "G16": {"grade_mm_s": 16.0, "description": "Drive shafts, agricultural machinery"},
    "G40": {"grade_mm_s": 40.0, "description": "Car wheels, engine blocks"},
}

def _validate_positive(value: float, label: str) -> float:
    if value <= 0.0:
        raise ValueError(f"{label} must be positive.")
    return value

def _validate_non_negative(value: float, label: str) -> float:
    if value < 0.0:
        raise ValueError(f"{label} cannot be negative.")
    return value

def generate_force_curve(
    unbalance_g_mm: float, 
    max_rpm: float, 
    points: int = 50
) -> Dict[str, List[float]]:
    """Generate centrifugal force vs RPM curve."""
    rpms = [i * max_rpm / (points - 1) for i in range(points)]
    forces = []
    for rpm in rpms:
        omega = rpm * math.pi / 30.0
        # F = U * omega^2 (U in kg*m)
        f = (unbalance_g_mm * 1e-6) * omega**2
        forces.append(f)
    return {"x_values": rpms, "y_values": forces}

def calculate_rotor_balance(
    rotor_mass_kg: float,
    operating_rpm: float,
    iso_grade: str,
    measured_unbalance_g_mm: float,
    correction_radius_mm: float,
) -> Dict[str, Any]:
    """
    Calculate ISO 1940-1 permissible unbalance, centrifugal forces, and correction masses.

    ---Parameters---
    rotor_mass_kg : float
        Total mass of the rotating assembly (kg).
    operating_rpm : float
        Maximum operating speed of the rotor (RPM).
    iso_grade : str
        Desired balance quality grade (e.g., G2.5, G6.3).
    measured_unbalance_g_mm : float
        Actual measured or estimated residual unbalance (g·mm). Set to 0 if only checking limits.
    correction_radius_mm : float
        Radius at which correction mass will be added or removed (mm).

    ---Returns---
    permissible_unbalance_g_mm : float
        Maximum allowable residual unbalance (U_per) based on ISO grade (g·mm).
    specific_unbalance_e_per_um : float
        Permissible specific unbalance or eccentricity of the center of gravity (e_per) (μm).
    centrifugal_force_n : float
        Radial force generated by the measured unbalance at operating speed (N).
    correction_mass_g : float
        Mass required at the correction radius to compensate for the measured unbalance (g).
    utilization_percent : float
        Percentage of permissible unbalance used by the measured unbalance (%).
    grade_description : str
        Typical applications for the selected ISO grade.
    status : str
        Acceptable if measured unbalance <= permissible, otherwise Unacceptable.
    subst_permissible_unbalance_g_mm : str
        Substituted equation for U_per (LaTeX).
    subst_centrifugal_force_n : str
        Substituted equation for Centrifugal Force (LaTeX).

    ---LaTeX---
    \\omega = \\frac{\\pi \\cdot n}{30}
    e_{per} = \\frac{1000 \\cdot G}{\\omega}
    U_{per} = m \\cdot e_{per}
    F_c = U_{measured} \\cdot 10^{-6} \\cdot \\omega^2
    m_{corr} = \\frac{U_{measured}}{r_{corr}}
    """
    
    m_kg = _validate_positive(rotor_mass_kg, "rotor_mass_kg")
    rpm = _validate_positive(operating_rpm, "operating_rpm")
    u_meas = _validate_non_negative(measured_unbalance_g_mm, "measured_unbalance_g_mm")
    r_corr = _validate_positive(correction_radius_mm, "correction_radius_mm")
    
    if iso_grade not in ISO_GRADES:
        raise ValueError(f"Unknown ISO grade: {iso_grade}")
    
    grade_info = ISO_GRADES[iso_grade]
    G_mm_s = grade_info["grade_mm_s"]
    desc = grade_info["description"]
    
    omega_rad_s = rpm * math.pi / 30.0
    
    # e_per in mm = G (mm/s) / omega (rad/s)
    e_per_mm = G_mm_s / omega_rad_s
    e_per_um = e_per_mm * 1000.0
    
    # U_per in g*mm = m_kg (kg = 1000g) * e_per (mm)
    u_per_g_mm = 1000.0 * m_kg * e_per_mm
    
    # Centrifugal Force F = m * r * omega^2
    # Since U is in g*mm, U_kg_m = U_g_mm * 1e-6
    u_meas_kg_m = u_meas * 1e-6
    force_n = u_meas_kg_m * omega_rad_s**2
    
    # Correction mass in g = U_g_mm / r_mm
    m_corr_g = u_meas / r_corr
    
    utilization = 0.0
    if u_per_g_mm > 0:
        utilization = (u_meas / u_per_g_mm) * 100.0
        
    status = "acceptable" if utilization <= 100.0 else "unacceptable"
    if u_meas == 0.0:
        status = "info" # Just checking limits
    
    subst_u_per = (
        f"U_{{per}} = 1000 \\cdot m \\cdot \\frac{{G}}{{\\omega}} = "
        f"1000 \\cdot {m_kg:.1f} \\cdot \\frac{{{G_mm_s:.1f}}}{{{omega_rad_s:.1f}}} = "
        f"{u_per_g_mm:.1f}\\,\\text{{g\\cdot mm}}"
    )
    
    subst_force = (
        f"F_c = U_{{meas}} \\cdot 10^{{-6}} \\cdot \\omega^2 = "
        f"{u_meas:.1f} \\cdot 10^{{-6}} \\cdot {omega_rad_s:.1f}^2 = "
        f"{force_n:.2f}\\,\\text{{N}}"
    )
    
    # Generate visualization data
    force_data = generate_force_curve(u_meas if u_meas > 0 else u_per_g_mm, rpm * 1.5)
    
    return {
        "permissible_unbalance_g_mm": u_per_g_mm,
        "specific_unbalance_e_per_um": e_per_um,
        "centrifugal_force_n": force_n,
        "correction_mass_g": m_corr_g,
        "utilization_percent": utilization,
        "grade_description": desc,
        "status": status,
        "subst_permissible_unbalance_g_mm": subst_u_per,
        "subst_centrifugal_force_n": subst_force,
        "force_curve_data": force_data,
        "nominal_rpm": rpm,
        "nominal_force": force_n,
    }
