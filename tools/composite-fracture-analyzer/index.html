<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-YG3SBRRZFZ"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-YG3SBRRZFZ');
    </script>

    <title>Composite Fracture Analyzer - Engineering Tools</title>

    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="https://cdn.jsdelivr.net/pyodide/v0.25.1/full/pyodide.js"></script>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>

    <style>
        /* =================================================================
           1. CSS VARIABLES & RESET
           ================================================================= */
        :root {
            --primary-color: #0b0d12;
            --primary-light: #f4f5f7;
            --secondary-color: #4b5563;
            --accent-color: #111827;
            --success-color: #0f766e;
            --warning-color: #b45309;
            --danger-color: #b91c1c;
            --text-color: #111827;
            --text-light: #6b7280;
            --border-color: #e5e7eb;
            --bg-color: #f8f9fb;
            --bg-card: #ffffff;
            --shadow: 0 1px 2px rgba(15, 23, 42, 0.08);
            --shadow-lg: 0 12px 28px rgba(15, 23, 42, 0.18);
            --border-radius: 8px;
            --font-sans: 'Helvetica Neue', 'Avenir Next', 'Univers', 'Helvetica', system-ui, sans-serif;
            --font-mono: 'SF Mono', 'Menlo', 'Monaco', monospace;
            --btn-primary-bg: #111827;
            --btn-primary-text: #ffffff;
            --tooltip-bg: #111827;
            --tooltip-text: #ffffff;
            --callout-info-bg: #dbeafe;
            --callout-info-border: #3b82f6;
            --callout-warning-bg: #fef3c7;
            --callout-warning-border: #f59e0b;
            --callout-danger-bg: #fef2f2;
            --callout-danger-border: #ef4444;
            --callout-success-bg: #d1fae5;
            --callout-success-border: #22c55e;
        }
        body[data-theme="dark"] {
            --primary-color: #f9fafb;
            --primary-light: #1f2937;
            --secondary-color: #9ca3af;
            --accent-color: #f9fafb;
            --success-color: #34d399;
            --warning-color: #fbbf24;
            --danger-color: #f87171;
            --text-color: #f9fafb;
            --text-light: #9ca3af;
            --border-color: #374151;
            --bg-color: #0b0d12;
            --bg-card: #111827;
            --shadow: 0 1px 2px rgba(0, 0, 0, 0.45);
            --shadow-lg: 0 16px 32px rgba(0, 0, 0, 0.55);
            --btn-primary-bg: #3b82f6;
            --btn-primary-text: #ffffff;
            --tooltip-bg: #1f2937;
            --tooltip-text: #f9fafb;
            --callout-info-bg: #1e3a5f;
            --callout-info-border: #3b82f6;
            --callout-warning-bg: #422006;
            --callout-warning-border: #f59e0b;
            --callout-danger-bg: #450a0a;
            --callout-danger-border: #ef4444;
            --callout-success-bg: #052e16;
            --callout-success-border: #22c55e;
        }
        @media (prefers-color-scheme: dark) {
            body[data-theme="system"] {
                --primary-color: #f9fafb;
                --primary-light: #1f2937;
                --secondary-color: #9ca3af;
                --accent-color: #f9fafb;
                --success-color: #34d399;
                --warning-color: #fbbf24;
                --danger-color: #f87171;
                --text-color: #f9fafb;
                --text-light: #9ca3af;
                --border-color: #374151;
                --bg-color: #0b0d12;
                --bg-card: #111827;
                --shadow: 0 1px 2px rgba(0, 0, 0, 0.45);
                --shadow-lg: 0 16px 32px rgba(0, 0, 0, 0.55);
                --btn-primary-bg: #3b82f6;
                --btn-primary-text: #ffffff;
                --tooltip-bg: #1f2937;
                --tooltip-text: #f9fafb;
                --callout-info-bg: #1e3a5f;
                --callout-info-border: #3b82f6;
                --callout-warning-bg: #422006;
                --callout-warning-border: #f59e0b;
                --callout-danger-bg: #450a0a;
                --callout-danger-border: #ef4444;
                --callout-success-bg: #052e16;
                --callout-success-border: #22c55e;
            }
        }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        html, body { height: 100%; }
        body {
            font-family: var(--font-sans);
            line-height: 1.6;
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            flex-direction: column;
            transition: background-color 0.2s ease, color 0.2s ease;
        }

        /* =================================================================
           CROSS-SECTION PREVIEW
           ================================================================= */
        #cross-section-svg {
            width: 100%;
            height: 280px;
            background: #ffffff;
            border: 1px solid var(--border-color);
            border-radius: 6px;
        }
        body[data-theme="dark"] #cross-section-svg { background: var(--bg-card); }
        @media (prefers-color-scheme: dark) {
            body[data-theme="system"] #cross-section-svg { background: var(--bg-card); }
        }

        /* =================================================================
           2. LOADING OVERLAY
           ================================================================= */
        .loading-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: var(--bg-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            transition: background-color 0.2s ease;
        }
        .loading-overlay.hidden { display: none; }
        .spinner {
            width: 50px;
            height: 50px;
            border: 4px solid var(--border-color);
            border-top-color: var(--accent-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
        .loading-text {
            margin-top: 16px;
            font-weight: 600;
            color: var(--text-color);
        }

        /* =================================================================
           3. LAYOUT & CONTAINERS
           ================================================================= */
        .container { width: 92%; max-width: 1400px; margin: 0 auto; padding: 24px 0; }
        .navbar { background-color: var(--bg-card); border-bottom: 1px solid var(--border-color); padding: 0 5%; }
        .nav-container { display: flex; justify-content: space-between; align-items: center; height: 64px; max-width: 1400px; margin: 0 auto; }
        .nav-brand { font-size: 1.35rem; font-weight: 600; color: var(--text-color); text-decoration: none; }
        .nav-brand:hover { text-decoration: none; }
        .nav-actions { display: flex; align-items: center; gap: 12px; }
        .settings-button {
            border: 1px solid var(--border-color);
            background: var(--bg-card);
            color: var(--text-color);
            font-weight: 600;
            font-size: 0.85rem;
            padding: 8px 14px;
            border-radius: 999px;
            cursor: pointer;
            transition: background-color 0.15s ease;
        }
        .settings-button:hover { background: var(--primary-light); }

        main.container { flex-grow: 1; }
        h1 { font-size: 2.25rem; letter-spacing: -0.02em; font-weight: 600; color: var(--primary-color); margin-bottom: 0.5rem; }
        h2 { font-size: 1.375rem; font-weight: 600; border-bottom: 1px solid var(--border-color); padding-bottom: 12px; margin-top: 0; margin-bottom: 1rem; }
        h3 { font-size: 1.1rem; font-weight: 600; color: var(--secondary-color); margin-bottom: 0.75rem; }
        h4 { font-size: 0.95rem; font-weight: 600; color: var(--text-color); margin-bottom: 0.5rem; }
        p { margin-bottom: 1em; color: var(--text-light); }
        a { color: var(--accent-color); text-decoration: none; }
        a:hover { text-decoration: underline; }

        .tool-description { font-size: 1.05rem; max-width: 80ch; margin-bottom: 1.5rem; }
        .tool-layout {
            display: grid;
            grid-template-columns: minmax(360px, 0.9fr) minmax(480px, 1.1fr);
            gap: 28px;
            align-items: start;
        }
        .card {
            background-color: var(--bg-card);
            border-radius: var(--border-radius);
            border: 1px solid var(--border-color);
            box-shadow: var(--shadow);
            padding: 24px;
        }

        /* =================================================================
           4. PURPOSE/README SECTION
           ================================================================= */
        details > summary { list-style: none; cursor: pointer; }
        details > summary::-webkit-details-marker { display: none; }
        .purpose-section { margin-bottom: 2rem; border: 1px solid var(--border-color); border-radius: var(--border-radius); background-color: var(--bg-card); }
        .purpose-section summary { padding: 16px 24px; font-size: 1.1rem; font-weight: 600; color: var(--secondary-color); }
        .purpose-section summary::after { content: '[Expand]'; float: right; font-size: 0.9rem; font-weight: 500; color: var(--text-light); }
        .purpose-section[open] > summary::after { content: '[Collapse]'; }
        .purpose-content { padding: 0 24px 24px 24px; border-top: 1px solid var(--border-color); }
        .purpose-content h3 { margin-top: 1rem; }
        .purpose-content ul { padding-left: 20px; margin-bottom: 1rem; }
        .purpose-content code { background-color: var(--primary-light); padding: 2px 6px; border-radius: 4px; font-size: 0.9rem; }

        /* =================================================================
           5. INPUT SECTION
           ================================================================= */
        .tool-inputs h2 { margin-top: 0; }
        .input-group { margin-bottom: 1.1rem; position: relative; }
        .input-group label { display: block; font-weight: 500; margin-bottom: 6px; font-size: 0.875rem; color: var(--text-color); }
        .input-group input[type="number"],
        .input-group input[type="text"],
        .input-group select {
            width: 100%;
            padding: 11px 14px;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            font-size: 0.95rem;
            font-family: var(--font-sans);
            background: var(--bg-card);
            color: var(--text-color);
            transition: border-color 0.15s ease;
        }
        .input-group input:focus, .input-group select:focus {
            outline: none;
            border-color: var(--text-color);
        }
        .input-group input[type="number"]::-webkit-inner-spin-button,
        .input-group input[type="number"]::-webkit-outer-spin-button { -webkit-appearance: none; }
        .input-group input[type="number"] { -moz-appearance: textfield; }

        .input-row { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; }

        /* Tooltip */
        .tooltip-trigger {
            display: inline-flex; align-items: center; justify-content: center;
            width: 18px; height: 18px;
            background-color: var(--primary-light);
            border: 1px solid var(--border-color);
            color: var(--text-light);
            border-radius: 50%;
            font-size: 11px; font-weight: bold;
            cursor: help;
            position: absolute; right: 10px; top: 36px;
        }
        .tooltip-trigger::after {
            content: attr(data-tooltip);
            position: absolute; bottom: 130%; left: 50%; transform: translateX(-50%);
            background-color: var(--tooltip-bg); color: var(--tooltip-text);
            padding: 10px 14px; border-radius: 8px;
            font-size: 12px; font-weight: 400; line-height: 1.5;
            white-space: normal; width: 240px;
            opacity: 0; visibility: hidden;
            transition: opacity 0.2s, visibility 0.2s;
            z-index: 10; box-shadow: var(--shadow-lg);
        }
        .tooltip-trigger:hover::after { opacity: 1; visibility: visible; }
        .tooltip-trigger.slider-tooltip {
            position: relative;
            top: auto;
            right: auto;
            margin-left: 6px;
            vertical-align: middle;
        }

        /* Expert Mode Toggle */
        .expert-mode-bar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px 14px;
            background: var(--primary-light);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            margin-bottom: 16px;
        }
        .expert-mode-label { font-size: 0.9rem; font-weight: 600; color: var(--text-color); }
        .expert-mode-hint { font-size: 0.8rem; color: var(--text-light); margin-left: 8px; font-weight: 400; }
        .expert-toggle { display: flex; align-items: center; gap: 8px; cursor: pointer; }
        .expert-toggle input {
            width: 40px; height: 22px;
            appearance: none; -webkit-appearance: none;
            background: var(--border-color);
            border-radius: 999px;
            position: relative;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        .expert-toggle input::before {
            content: '';
            position: absolute;
            width: 16px; height: 16px;
            background: var(--bg-card);
            border-radius: 50%;
            top: 3px; left: 3px;
            transition: transform 0.2s ease;
            box-shadow: var(--shadow);
        }
        .expert-toggle input:checked { background: var(--success-color); }
        .expert-toggle input:checked::before { transform: translateX(18px); }
        .expert-toggle-label { font-size: 0.85rem; font-weight: 600; color: var(--text-color); }

        /* Advanced Section */
        .advanced-section {
            display: none;
            margin-top: 16px;
            padding-top: 16px;
            border-top: 1px dashed var(--border-color);
        }
        .advanced-section h4 { margin-bottom: 12px; color: var(--secondary-color); font-size: 0.9rem; }
        body.expert-mode .advanced-section { display: block; }

        /* Slider */
        .slider-group { margin: 0 0 1.5rem 0; padding: 16px; background: var(--primary-light); border-radius: var(--border-radius); }
        .slider-header { display: flex; justify-content: space-between; margin-bottom: 8px; font-weight: 500; font-size: 0.875rem; }
        .slider-value { font-family: var(--font-mono); font-weight: 600; color: var(--accent-color); }
        .slider-group input[type="range"] {
            width: 100%; height: 6px; -webkit-appearance: none;
            background: var(--border-color); border-radius: 3px; outline: none;
        }
        .slider-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none; width: 18px; height: 18px;
            background: var(--accent-color); border-radius: 50%; cursor: pointer;
        }
        .slider-labels { display: flex; justify-content: space-between; font-size: 0.75rem; color: var(--text-light); margin-top: 4px; }

        /* Buttons */
        .btn { display: inline-block; padding: 12px 16px; font-size: 1rem; font-weight: 600; border: none; border-radius: var(--border-radius); cursor: pointer; text-align: center; transition: background-color 0.15s, opacity 0.15s; }
        .btn-primary { background-color: var(--btn-primary-bg); color: var(--btn-primary-text); width: 100%; }
        .btn-primary:hover { opacity: 0.9; }
        .btn-secondary { background-color: transparent; color: var(--text-color); border: 1px solid var(--border-color); }
        .btn-secondary:hover { background-color: var(--primary-light); }

        /* =================================================================
           6. TABS
           ================================================================= */
        .tabs { display: flex; border-bottom: 1px solid var(--border-color); margin-bottom: 24px; gap: 4px; flex-wrap: wrap; }
        .tab-link {
            padding: 12px 16px; cursor: pointer;
            background-color: transparent; border: none;
            font-size: 0.85rem; font-weight: 600; letter-spacing: 0.03em; text-transform: uppercase;
            color: var(--text-light);
            border-bottom: 2px solid transparent; margin-bottom: -2px;
            transition: color 0.2s ease;
        }
        .tab-link:hover { color: var(--text-color); }
        .tab-link.active { color: var(--text-color); border-bottom-color: var(--accent-color); }
        .tab-content { display: none; animation: fadeIn 0.4s ease; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(8px); } to { opacity: 1; transform: translateY(0); } }

        /* Sensitivity controls */
        .sensitivity-controls { margin-bottom: 16px; }
        .sweep-progress-bar {
            width: 100%; height: 6px;
            background: var(--border-color);
            border-radius: 3px;
            overflow: hidden;
        }
        .sweep-progress-fill {
            height: 100%;
            background: var(--success-color);
            border-radius: 3px;
            transition: width 0.15s ease;
        }
        .sweep-progress-text {
            display: block;
            font-size: 0.8rem;
            color: var(--text-light);
            margin-top: 4px;
            text-align: right;
        }

        /* =================================================================
           7. RESULTS SECTION
           ================================================================= */
        .results-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 14px;
            margin-bottom: 20px;
        }
        .result-item {
            background: var(--bg-color);
            padding: 16px;
            border-radius: var(--border-radius);
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
            border: 2px solid transparent;
        }
        .result-item:hover { border-color: var(--border-color); }
        .result-item.expanded { border-color: var(--accent-color); background: var(--primary-light); }
        .result-item.highlight { background: var(--primary-light); border-left: 3px solid var(--accent-color); }
        .result-item .label { font-size: 0.8rem; color: var(--text-light); margin-bottom: 4px; }
        .result-item .value { font-size: 1.25rem; font-weight: 600; font-family: var(--font-mono); }
        .result-item .unit { font-size: 0.8rem; color: var(--text-light); margin-left: 2px; }
        .result-item .icon { font-size: 0.65rem; margin-left: 4px; opacity: 0.4; }

        /* Derivation Panel */
        .derivation-panel {
            display: none;
            background: var(--primary-light);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            padding: 20px;
            margin-bottom: 20px;
        }
        .derivation-panel.visible { display: block; animation: fadeIn 0.3s ease; }
        .derivation-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px; }
        .derivation-title { font-weight: 600; font-size: 1rem; }
        .derivation-close { background: none; border: none; font-size: 1.25rem; cursor: pointer; color: var(--text-light); }
        .derivation-close:hover { color: var(--text-color); }
        .derivation-step { margin-bottom: 16px; padding-bottom: 16px; border-bottom: 1px solid var(--border-color); }
        .derivation-step:last-child { border-bottom: none; margin-bottom: 0; padding-bottom: 0; }
        .derivation-step .step-title { font-weight: 500; margin-bottom: 8px; color: var(--text-color); font-size: 0.9rem; }
        .derivation-step .equation { background: var(--bg-card); padding: 12px; border-radius: 6px; font-size: 0.95rem; overflow-x: auto; }

        /* =================================================================
           8. SAFETY GAUGES
           ================================================================= */
        .safety-section { margin-top: 24px; }
        .safety-section h4 { margin-bottom: 16px; color: var(--secondary-color); }
        .safety-gauge {
            display: flex; align-items: center; gap: 14px;
            margin-bottom: 12px; padding: 12px 16px;
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
        }
        .gauge-label { min-width: 120px; font-weight: 600; font-size: 0.85rem; }
        .gauge-bar-container { flex: 1; height: 8px; background: var(--border-color); border-radius: 4px; position: relative; overflow: visible; }
        .gauge-bar { height: 100%; border-radius: 4px; transition: width 0.4s ease; }
        .gauge-bar.success { background: var(--success-color); }
        .gauge-bar.warning { background: var(--warning-color); }
        .gauge-bar.danger { background: var(--danger-color); }
        .gauge-value { min-width: 70px; text-align: right; font-family: var(--font-mono); font-weight: 600; font-size: 0.9rem; }
        .gauge-value.success { color: var(--success-color); }
        .gauge-value.warning { color: var(--warning-color); }
        .gauge-value.danger { color: var(--danger-color); }
        .gauge-threshold { position: absolute; width: 2px; height: 16px; background: var(--text-color); top: -4px; }

        /* Gauge Explainer */
        .gauge-explainer {
            display: none;
            background: var(--primary-light);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            padding: 16px;
            margin-bottom: 12px;
            animation: fadeIn 0.3s ease;
        }
        .gauge-explainer.visible { display: block; }
        .gauge-explainer .explainer-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
        .gauge-explainer p { font-size: 0.9rem; margin-bottom: 10px; }
        .gauge-explainer .explainer-equation { background: var(--bg-card); padding: 10px; border-radius: 6px; margin-bottom: 10px; font-size: 0.95rem; }
        .gauge-explainer .explainer-values { display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 10px; }
        .gauge-explainer .value-tag { background: var(--bg-card); border: 1px solid var(--border-color); padding: 4px 10px; border-radius: 20px; font-size: 0.8rem; font-family: var(--font-mono); color: var(--text-color); }
        .gauge-explainer .explainer-guidance { font-size: 0.85rem; padding: 10px; border-radius: 6px; margin-bottom: 0; }
        .gauge-explainer .explainer-guidance.good { background: var(--callout-success-bg); color: var(--success-color); }
        .gauge-explainer .explainer-guidance.marginal { background: var(--callout-warning-bg); color: var(--warning-color); }
        .gauge-explainer .explainer-guidance.bad { background: var(--callout-danger-bg); color: var(--danger-color); }

        /* =================================================================
           9. STATUS BANNER
           ================================================================= */
        .status-banner { padding: 18px 24px; border-radius: var(--border-radius); margin-top: 24px; display: flex; align-items: flex-start; gap: 14px; }
        .status-banner .icon { font-size: 1.25rem; }
        .status-banner .content h4 { margin-bottom: 4px; }
        .status-banner .content p { margin-bottom: 0; font-size: 0.9rem; }
        .status-banner.acceptable { background: #ecfdf5; border: 1px solid var(--success-color); }
        .status-banner.acceptable h4 { color: var(--success-color); }
        .status-banner.marginal { background: #fffbeb; border: 1px solid var(--warning-color); }
        .status-banner.marginal h4 { color: var(--warning-color); }
        .status-banner.unacceptable { background: #fef2f2; border: 1px solid var(--danger-color); }
        .status-banner.unacceptable h4 { color: var(--danger-color); }
        .recommendations { margin-top: 8px; padding-left: 20px; }
        .recommendations li { font-size: 0.85rem; margin-bottom: 4px; color: var(--text-color); }

        /* =================================================================
           10. CHARTS
           ================================================================= */
        .chart-container { background: var(--bg-card); border: 1px solid var(--border-color); border-radius: var(--border-radius); padding: 18px; margin-bottom: 20px; }
        .chart-container h4 { margin-bottom: 12px; font-size: 0.95rem; font-weight: 600; color: var(--text-color); }
        .chart-plot { width: 100%; min-height: 350px; height: 350px; }
        .chart-explanation { margin-top: 12px; font-size: 0.85rem; color: var(--text-light); line-height: 1.5; padding: 10px; background: var(--primary-light); border-radius: 6px; }
        .chart-explanation strong { color: var(--text-color); }
        .charts-grid { display: grid; grid-template-columns: 1fr; gap: 20px; }

        /* =================================================================
           11. BACKGROUND TAB
           ================================================================= */
        .toc-card { background: var(--primary-light); padding: 16px 20px; border-radius: 8px; margin-bottom: 24px; }
        .toc-card strong { color: var(--primary-color); }
        .toc-card ol { margin: 10px 0 0 20px; color: var(--text-light); font-size: 0.9rem; }
        .toc-card a { color: var(--accent-color); }

        .bg-section { margin-bottom: 32px; }
        .bg-section h3 { border-bottom: 2px solid var(--accent-color); padding-bottom: 8px; margin-bottom: 16px; }
        .bg-section h4 { margin-top: 20px; color: var(--secondary-color); }

        .equation-card { background: var(--bg-card); border: 1px solid var(--border-color); border-radius: var(--border-radius); padding: 16px 20px; margin: 16px 0; }
        .equation-card strong { display: block; margin-bottom: 8px; color: var(--secondary-color); font-size: 0.9rem; }
        .equation-card .equation-expression { display: block; margin-bottom: 10px; font-size: 1.05rem; }
        .equation-card ul { list-style: none; padding-left: 0; display: grid; gap: 6px; font-size: 0.85rem; color: var(--text-light); }

        .callout-info { background: var(--callout-info-bg); border-left: 4px solid var(--callout-info-border); padding: 12px 16px; margin: 16px 0; border-radius: 0 8px 8px 0; color: var(--text-color); }
        .callout-info strong { color: var(--callout-info-border); }
        .callout-warning { background: var(--callout-warning-bg); border-left: 4px solid var(--callout-warning-border); padding: 12px 16px; margin: 16px 0; border-radius: 0 8px 8px 0; color: var(--text-color); }
        .callout-warning strong { color: var(--callout-warning-border); }
        .callout-danger { background: var(--callout-danger-bg); border-left: 4px solid var(--callout-danger-border); padding: 12px 16px; margin: 16px 0; border-radius: 0 8px 8px 0; color: var(--text-color); }
        .callout-danger strong { color: var(--callout-danger-border); }
        .callout-success { background: var(--callout-success-bg); border-left: 4px solid var(--callout-success-border); padding: 12px 16px; margin: 16px 0; border-radius: 0 8px 8px 0; color: var(--text-color); }
        .callout-success strong { color: var(--callout-success-border); }

        /* Material table */
        .mat-table { width: 100%; border-collapse: collapse; font-size: 0.85rem; margin: 16px 0; }
        .mat-table th, .mat-table td { padding: 8px 10px; border: 1px solid var(--border-color); text-align: left; }
        .mat-table th { background: var(--primary-light); font-weight: 600; color: var(--secondary-color); }
        .mat-table td { font-family: var(--font-mono); font-size: 0.8rem; }

        /* =================================================================
           12. SETTINGS PANEL
           ================================================================= */
        .settings-overlay {
            position: fixed; inset: 0;
            background: rgba(0, 0, 0, 0.2);
            opacity: 0; visibility: hidden;
            transition: opacity 0.2s ease, visibility 0.2s ease;
            z-index: 1000;
        }
        .settings-overlay.open { opacity: 1; visibility: visible; }
        .settings-panel {
            position: fixed; top: 0; right: 0;
            width: 360px; height: 100vh;
            background: var(--bg-card);
            border-left: 1px solid var(--border-color);
            box-shadow: var(--shadow-lg);
            transform: translateX(100%);
            transition: transform 0.25s ease;
            z-index: 1001;
            display: flex; flex-direction: column;
        }
        .settings-panel.open { transform: translateX(0); }
        .settings-header { display: flex; justify-content: space-between; align-items: center; padding: 18px 24px; border-bottom: 1px solid var(--border-color); }
        .settings-header h3 { margin: 0; font-size: 1.1rem; }
        .settings-close { background: none; border: none; font-size: 0.9rem; font-weight: 600; color: var(--text-light); cursor: pointer; }
        .settings-close:hover { color: var(--text-color); }
        .settings-content { padding: 20px 24px; overflow-y: auto; flex: 1; }
        .settings-section { margin-bottom: 24px; }
        .settings-section h4 { margin-bottom: 14px; font-size: 0.95rem; color: var(--secondary-color); }
        .setting-row { display: flex; align-items: center; justify-content: space-between; gap: 14px; margin-bottom: 16px; }
        .setting-label { font-weight: 600; font-size: 0.9rem; color: var(--text-color); }
        .setting-help { font-size: 0.8rem; color: var(--text-light); margin-top: 2px; }
        .settings-footer { padding: 18px 24px; border-top: 1px solid var(--border-color); }

        /* Toggle Switch */
        .switch { position: relative; display: inline-block; width: 44px; height: 24px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .switch .slider-toggle {
            position: absolute; cursor: pointer;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: var(--border-color);
            transition: 0.2s; border-radius: 999px;
        }
        .switch .slider-toggle::before {
            position: absolute; content: '';
            height: 18px; width: 18px;
            left: 3px; bottom: 3px;
            background-color: var(--bg-card);
            transition: 0.2s; border-radius: 50%;
            box-shadow: var(--shadow);
        }
        .switch input:checked + .slider-toggle { background-color: var(--accent-color); }
        .switch input:checked + .slider-toggle::before { transform: translateX(20px); }

        /* Segmented Control */
        .segmented { display: inline-flex; gap: 4px; background: var(--primary-light); border: 1px solid var(--border-color); border-radius: 999px; padding: 4px; }
        .segmented button { border: none; background: transparent; color: var(--text-light); font-size: 0.8rem; font-weight: 600; padding: 6px 10px; border-radius: 999px; cursor: pointer; transition: all 0.15s ease; }
        .segmented button:hover { color: var(--text-color); }
        .segmented button.active { background: var(--accent-color); color: var(--bg-card); }

        /* =================================================================
           13. COMPACT DENSITY
           ================================================================= */
        body[data-density="compact"] .container { padding: 16px 0; }
        body[data-density="compact"] .card { padding: 12px; }
        body[data-density="compact"] .tool-layout { gap: 16px; }
        body[data-density="compact"] h1 { font-size: 1.7rem; margin-bottom: 0.25rem; }
        body[data-density="compact"] h2 { font-size: 1.1rem; padding-bottom: 8px; margin-bottom: 10px; }
        body[data-density="compact"] .tool-description { font-size: 0.9rem; margin-bottom: 1rem; }
        body[data-density="compact"] .input-group { margin-bottom: 10px; }
        body[data-density="compact"] .input-group label { font-size: 0.78rem; margin-bottom: 3px; }
        body[data-density="compact"] .input-group input,
        body[data-density="compact"] .input-group select { padding: 6px 10px; font-size: 0.85rem; }
        body[data-density="compact"] .input-group .tooltip-trigger { top: 28px; }
        body[data-density="compact"] .input-row { gap: 10px; }
        body[data-density="compact"] .slider-group { padding: 8px 12px; margin-bottom: 10px; }
        body[data-density="compact"] .slider-header { margin-bottom: 6px; font-size: 0.8rem; }
        body[data-density="compact"] .slider-labels { font-size: 0.7rem; }
        body[data-density="compact"] .expert-mode-bar { padding: 8px 12px; margin-bottom: 10px; }
        body[data-density="compact"] .expert-mode-label { font-size: 0.82rem; }
        body[data-density="compact"] .expert-mode-hint { font-size: 0.75rem; }
        body[data-density="compact"] .advanced-section { margin-top: 10px; padding-top: 10px; }
        body[data-density="compact"] .btn-primary { padding: 10px 20px; font-size: 0.9rem; }
        body[data-density="compact"] .tabs { margin-bottom: 12px; }
        body[data-density="compact"] .result-item { padding: 8px 12px; }
        body[data-density="compact"] .result-item .label { font-size: 0.78rem; }
        body[data-density="compact"] .result-item .value { font-size: 1rem; }
        body[data-density="compact"] .safety-gauge { padding: 8px 12px; margin-bottom: 8px; }
        body[data-density="compact"] .gauge-label { font-size: 0.78rem; }
        body[data-density="compact"] .gauge-value { font-size: 0.85rem; }
        body[data-density="compact"] .status-banner { padding: 12px 14px; margin-bottom: 12px; }

        /* =================================================================
           14. FOOTER
           ================================================================= */
        .footer { text-align: center; padding: 20px 0; background-color: var(--bg-card); border-top: 1px solid var(--border-color); color: var(--text-light); font-size: 0.9rem; margin-top: 30px; }

        /* =================================================================
           15. RESPONSIVE
           ================================================================= */
        @media (max-width: 1000px) {
            .tool-layout { grid-template-columns: 1fr; }
            .charts-grid { grid-template-columns: 1fr; }
        }
        @media (max-width: 720px) {
            .settings-panel { width: 100%; }
            .settings-button { padding: 8px 12px; font-size: 0.8rem; }
        }
        @media (max-width: 600px) {
            .input-row { grid-template-columns: 1fr; }
            .results-grid { grid-template-columns: 1fr; }
            .safety-gauge { flex-direction: column; align-items: flex-start; }
            .gauge-bar-container { width: 100%; }
            .tabs { flex-direction: column; }
            .segmented { flex-wrap: wrap; }
            .mat-table { font-size: 0.75rem; }
        }

        .support-link { color: inherit; font-weight: 600; text-decoration: none; }
        .support-link:hover { text-decoration: underline; }
    </style>
</head>

<body data-theme="system" data-density="comfortable">
    <!-- Loading Overlay -->
    <div class="loading-overlay" id="loading-overlay">
        <div class="spinner"></div>
        <div class="loading-text" id="loading-text">Loading Pyodide...</div>
    </div>

    <header class="navbar">
        <nav class="nav-container">
            <a href="../../index.html" class="nav-brand">Engineering Tools</a>
            <div class="nav-actions">
                <button class="settings-button" id="settings-button" type="button">Tool Settings</button>
            </div>
        </nav>
    </header>

    <!-- Settings Overlay & Panel -->
    <div class="settings-overlay" id="settings-overlay" aria-hidden="true"></div>
    <aside class="settings-panel" id="settings-panel" aria-hidden="true">
        <div class="settings-header">
            <h3>Tool Settings</h3>
            <button class="settings-close" id="settings-close" type="button">Close</button>
        </div>
        <div class="settings-content">
            <div class="settings-section">
                <h4>Behavior</h4>
                <div class="setting-row">
                    <div>
                        <div class="setting-label">Show derivations by default</div>
                        <div class="setting-help">Auto-expand derivation panels.</div>
                    </div>
                    <label class="switch">
                        <input type="checkbox" id="setting-show-derivations">
                        <span class="slider-toggle"></span>
                    </label>
                </div>
                <div class="setting-row">
                    <div>
                        <div class="setting-label">Show gauge explainers</div>
                        <div class="setting-help">Auto-expand safety gauge details.</div>
                    </div>
                    <label class="switch">
                        <input type="checkbox" id="setting-show-gauges">
                        <span class="slider-toggle"></span>
                    </label>
                </div>
            </div>
            <div class="settings-section">
                <h4>Appearance</h4>
                <div class="setting-row">
                    <div>
                        <div class="setting-label">Theme</div>
                        <div class="setting-help">Light, dark, or system default.</div>
                    </div>
                    <div class="segmented" role="group" aria-label="Theme">
                        <button type="button" data-theme="light">Light</button>
                        <button type="button" data-theme="dark">Dark</button>
                        <button type="button" data-theme="system">System</button>
                    </div>
                </div>
                <div class="setting-row">
                    <div>
                        <div class="setting-label">Density</div>
                        <div class="setting-help">Adjust spacing and sizing.</div>
                    </div>
                    <div class="segmented" role="group" aria-label="Density">
                        <button type="button" data-density="comfortable">Comfort</button>
                        <button type="button" data-density="compact">Compact</button>
                    </div>
                </div>
                <div class="setting-row">
                    <div>
                        <div class="setting-label">Precision</div>
                        <div class="setting-help">Decimal places in results.</div>
                    </div>
                    <div class="segmented" role="group" aria-label="Precision">
                        <button type="button" data-precision="2">2 dp</button>
                        <button type="button" data-precision="3">3 dp</button>
                        <button type="button" data-precision="4">4 dp</button>
                    </div>
                </div>
            </div>
        </div>
        <div class="settings-footer">
            <button class="btn btn-secondary" id="settings-reset" type="button" style="width: 100%;">Reset to Defaults</button>
        </div>
    </aside>

    <main class="container">
        <h1>Composite Fracture Analyzer</h1>
        <p class="tool-description" id="tool-description">
            Assess fracture risk and fatigue crack growth in fiber-reinforced polymer rotors under centrifugal loading.
            Combines LEFM stress intensity analysis with Paris-law crack growth life prediction.
        </p>

        <details class="purpose-section">
            <summary>Tool Purpose & README</summary>
            <div class="purpose-content" id="readme-content">
                <h3>About This Tool</h3>
                <p>The <strong>Composite Fracture Analyzer</strong> evaluates two tightly coupled failure modes for rotating composite components:</p>
                <ul>
                    <li><strong>Static fracture assessment</strong> &mdash; stress intensity factor K<sub>I</sub> vs fracture toughness K<sub>IC</sub>, critical crack size</li>
                    <li><strong>Fatigue crack growth</strong> &mdash; Paris law integration (da/dN = C(&Delta;K)<sup>m</sup>) to determine remaining life</li>
                </ul>
                <h3>When to Use</h3>
                <ul>
                    <li>Early-stage damage tolerance assessment of composite flywheel rotors, centrifuge components, or turbine disks</li>
                    <li>Estimating inspection intervals for rotating components with known defects</li>
                    <li>Comparing material choices (CFRP, GFRP, Aramid, filled polymers) for crack resistance</li>
                </ul>
                <h3>Limitations</h3>
                <ul>
                    <li>Assumes linear-elastic fracture mechanics (LEFM) &mdash; small-scale yielding only</li>
                    <li>Uses simplified geometry factors; does not account for complex 3D stress fields</li>
                    <li>Composite anisotropy is not modeled; properties represent effective isotropic behavior</li>
                    <li>Paris law constants are approximate; use test data for critical applications</li>
                </ul>
            </div>
        </details>

        <div class="tool-layout">
            <!-- ============== INPUTS ============== -->
            <section class="tool-inputs card">
                <h2>Inputs</h2>

                <!-- Expert Mode Toggle -->
                <div class="expert-mode-bar">
                    <div>
                        <span class="expert-mode-label">Expert Mode</span>
                        <span class="expert-mode-hint">Show all parameters</span>
                    </div>
                    <label class="expert-toggle">
                        <input type="checkbox" id="expert-mode-toggle" onchange="toggleExpertMode()">
                        <span class="expert-toggle-label" id="expert-mode-status">Off</span>
                    </label>
                </div>

                <form id="calc-form">
                    <!-- Geometry -->
                    <div class="input-group">
                        <label for="geometry_type">Geometry Type</label>
                        <select id="geometry_type" name="geometry_type" onchange="onGeometryChange()">
                            <option value="annular_disk">Annular Disk</option>
                            <option value="solid_disk">Solid Disk</option>
                            <option value="thin_ring">Thin Ring</option>
                        </select>
                        <span class="tooltip-trigger" data-tooltip="Rotor geometry: annular disk (with bore), solid disk (no bore), or thin ring approximation.">?</span>
                    </div>

                    <div class="input-row">
                        <div class="input-group" id="inner-radius-group">
                            <label for="inner_radius_mm">Inner Radius (mm)</label>
                            <input type="number" id="inner_radius_mm" name="inner_radius_mm" value="25" step="any" min="0.1">
                            <span class="tooltip-trigger" data-tooltip="Inner bore radius. Ignored for solid disk geometry.">?</span>
                        </div>
                        <div class="input-group">
                            <label for="outer_radius_mm">Outer Radius (mm)</label>
                            <input type="number" id="outer_radius_mm" name="outer_radius_mm" value="100" step="1" min="1">
                            <span class="tooltip-trigger" data-tooltip="Outer radius of the rotor in mm.">?</span>
                        </div>
                    </div>

                    <div class="input-row">
                        <div class="input-group">
                            <label for="thickness_mm">Thickness (mm)</label>
                            <input type="number" id="thickness_mm" name="thickness_mm" value="10" step="any" min="0.1">
                            <span class="tooltip-trigger" data-tooltip="Axial thickness of the component.">?</span>
                        </div>
                        <div class="input-group">
                            <label for="speed_rpm">Speed (RPM)</label>
                            <input type="number" id="speed_rpm" name="speed_rpm" value="10000" step="any" min="1">
                            <span class="tooltip-trigger" data-tooltip="Rotational speed in revolutions per minute.">?</span>
                        </div>
                    </div>

                    <!-- Material -->
                    <div class="input-group">
                        <label for="material_preset">Material</label>
                        <select id="material_preset" name="material_preset" onchange="onMaterialChange()">
                            <option value="pa6_gf30">30% Glass-filled Nylon (PA6-GF30)</option>
                            <option value="peek_cf30">30% Carbon-filled PEEK (PEEK-CF30)</option>
                            <option value="cfrp_hoop_wound">Carbon Fiber / Epoxy (Hoop-wound)</option>
                            <option value="gfrp_epoxy">Glass Fiber / Epoxy</option>
                            <option value="aramid_epoxy">Aramid / Epoxy (Kevlar)</option>
                            <option value="generic_polymer">Generic Isotropic Polymer</option>
                            <option value="custom">Custom Material</option>
                        </select>
                        <span class="tooltip-trigger" data-tooltip="Select a preset to auto-fill fracture properties, or choose Custom for manual entry.">?</span>
                    </div>

                    <!-- Crack Parameters -->
                    <div class="input-row">
                        <div class="input-group">
                            <label for="crack_location_radius_mm">Crack Location (mm)</label>
                            <input type="number" id="crack_location_radius_mm" name="crack_location_radius_mm" value="30" step="1" min="0">
                            <span class="tooltip-trigger" data-tooltip="Radial position of the crack from the rotation axis, in mm.">?</span>
                        </div>
                        <div class="input-group">
                            <label for="initial_crack_size_mm">Crack Size (mm)</label>
                            <input type="number" id="initial_crack_size_mm" name="initial_crack_size_mm" value="1.0" step="any" min="0.01">
                            <span class="tooltip-trigger" data-tooltip="Initial crack half-length (through/embedded) or depth (edge/surface), in mm.">?</span>
                        </div>
                    </div>

                    <div class="input-group">
                        <label for="crack_type">Crack Type</label>
                        <select id="crack_type" name="crack_type" onchange="onCrackTypeChange()">
                            <option value="edge">Edge Crack</option>
                            <option value="through">Through Crack</option>
                            <option value="surface">Surface Crack (semi-circular)</option>
                            <option value="embedded">Embedded (penny-shaped)</option>
                            <option value="elliptical_surface">Elliptical Surface Crack</option>
                            <option value="corner">Corner Crack</option>
                            <option value="double_edge">Double Edge Crack</option>
                        </select>
                        <span class="tooltip-trigger" data-tooltip="Crack geometry affects the stress intensity geometry factor Y.">?</span>
                        <svg id="crack-type-diagram" viewBox="0 0 340 110" role="img" aria-label="Crack type diagrams" style="width: 100%; height: 110px; margin-top: 6px; border-radius: 6px; border: 1px solid var(--border-color);"></svg>
                    </div>

                    <div class="input-group" id="aspect-ratio-group" style="display: none;">
                        <label for="crack_aspect_ratio">Crack Aspect Ratio (a/c)</label>
                        <input type="number" id="crack_aspect_ratio" name="crack_aspect_ratio" value="1.0" step="0.1" min="0.1" max="10">
                        <span class="tooltip-trigger" data-tooltip="Ratio of crack depth (a) to half-surface-length (c). 1.0 = semicircular. < 1 = elongated surface flaw. > 1 = deep narrow flaw.">?</span>
                    </div>

                    <!-- Required SF slider -->
                    <div class="slider-group">
                        <div class="slider-header">
                            <span>Required Safety Factor <span class="tooltip-trigger slider-tooltip" data-tooltip="Minimum acceptable K_IC/K_I ratio. 1.5 = standard for non-critical, 2.0 = safety-critical, 3.0+ = very conservative.">?</span></span>
                            <span class="slider-value" id="sf_display">1.5</span>
                        </div>
                        <input type="range" id="required_fracture_sf" name="required_fracture_sf" min="1.0" max="4.0" step="0.1" value="1.5" oninput="document.getElementById('sf_display').textContent=parseFloat(this.value).toFixed(1)">
                        <div class="slider-labels">
                            <span>1.0 (Minimum)</span>
                            <span>4.0 (Conservative)</span>
                        </div>
                    </div>

                    <!-- Expert-mode inputs -->
                    <div class="advanced-section" id="advanced-inputs">
                        <h4>Crack Orientation</h4>
                        <div class="input-group">
                            <label for="crack_orientation">Orientation</label>
                            <select id="crack_orientation" name="crack_orientation">
                                <option value="circumferential">Circumferential (opens under radial stress)</option>
                                <option value="radial">Radial (opens under hoop stress, ligament = thickness)</option>
                            </select>
                            <span class="tooltip-trigger" data-tooltip="Crack orientation determines which stress component drives fracture and the ligament width.">?</span>
                            <svg id="crack-orientation-diagram" viewBox="0 0 340 110" role="img" aria-label="Crack orientation diagrams" style="width: 100%; height: 110px; margin-top: 6px; border-radius: 6px; border: 1px solid var(--border-color);"></svg>
                        </div>

                        <h4 style="margin-top: 16px;">Material Properties</h4>
                        <div class="input-row">
                            <div class="input-group">
                                <label for="fracture_toughness">K<sub>IC</sub> (MPa&radic;m)</label>
                                <input type="number" id="fracture_toughness" name="fracture_toughness" value="7.0" step="any" min="0.1">
                                <span class="tooltip-trigger" data-tooltip="Plane-strain fracture toughness. Overridden by material preset (except Custom).">?</span>
                            </div>
                            <div class="input-group">
                                <label for="tensile_strength_mpa">UTS (MPa)</label>
                                <input type="number" id="tensile_strength_mpa" name="tensile_strength_mpa" value="180" step="any" min="1">
                                <span class="tooltip-trigger" data-tooltip="Ultimate tensile strength. Overridden by material preset.">?</span>
                            </div>
                        </div>
                        <div class="input-row">
                            <div class="input-group">
                                <label for="density_kg_m3">Density (kg/m&sup3;)</label>
                                <input type="number" id="density_kg_m3" name="density_kg_m3" value="1360" step="any" min="1">
                                <span class="tooltip-trigger" data-tooltip="Material density. Overridden by material preset.">?</span>
                            </div>
                            <div class="input-group">
                                <label for="poisson_ratio">Poisson Ratio</label>
                                <input type="number" id="poisson_ratio" name="poisson_ratio" value="0.35" step="0.01" min="0" max="0.49">
                                <span class="tooltip-trigger" data-tooltip="Poisson's ratio for stress calculation. Not overridden by preset.">?</span>
                            </div>
                        </div>

                        <h4 style="margin-top: 16px;">Paris Law Parameters</h4>
                        <div class="input-row">
                            <div class="input-group">
                                <label for="paris_C">Paris C</label>
                                <input type="number" id="paris_C" name="paris_C" value="5e-8" step="any" min="0">
                                <span class="tooltip-trigger" data-tooltip="Paris law coefficient C (da/dN in m/cycle, Delta-K in MPa*sqrt(m)). Overridden by preset.">?</span>
                            </div>
                            <div class="input-group">
                                <label for="paris_m">Paris m</label>
                                <input type="number" id="paris_m" name="paris_m" value="5.0" step="0.1" min="0.1">
                                <span class="tooltip-trigger" data-tooltip="Paris law exponent m. Overridden by material preset.">?</span>
                            </div>
                        </div>

                        <h4 style="margin-top: 16px;">Loading & Design</h4>
                        <div class="input-row">
                            <div class="input-group">
                                <label for="stress_ratio_R">Stress Ratio R</label>
                                <input type="number" id="stress_ratio_R" name="stress_ratio_R" value="0.0" step="0.05" min="0" max="0.99">
                                <span class="tooltip-trigger" data-tooltip="R = sigma_min/sigma_max. 0 = zero-to-max cycling (start-stop rotor), 0.1 = typical with residual stress.">?</span>
                            </div>
                            <div class="input-group">
                                <label for="design_life_cycles">Design Life (cycles)</label>
                                <input type="number" id="design_life_cycles" name="design_life_cycles" value="100000" step="any" min="1">
                                <span class="tooltip-trigger" data-tooltip="Target number of start-stop load cycles over the component service life.">?</span>
                            </div>
                        </div>
                    </div>

                    <button type="submit" class="btn btn-primary" id="calculate-btn" style="margin-top: 16px;">Calculate</button>
                </form>
            </section>

            <!-- ============== OUTPUTS ============== -->
            <section class="tool-outputs card">
                <div class="tabs">
                    <button class="tab-link active" onclick="openTab(event, 'results')">Fracture</button>
                    <button class="tab-link" onclick="openTab(event, 'crack-growth')">Crack Growth</button>
                    <button class="tab-link" onclick="openTab(event, 'visualization')">Visualization</button>
                    <button class="tab-link" onclick="openTab(event, 'sensitivity')">Sensitivity</button>
                    <button class="tab-link" onclick="openTab(event, 'background')">Background</button>
                </div>

                <!-- Fracture Assessment Tab -->
                <div id="results" class="tab-content" style="display: block;">
                    <h3>Fracture Assessment</h3>
                    <p id="results-placeholder" style="color: var(--text-light);">Enter inputs and press Calculate to see results.</p>

                    <div class="results-grid" id="results-grid" style="display: none;">
                        <div class="result-item highlight" data-key="K_I" onclick="toggleDerivation('K_I')">
                            <div class="label">K<sub>I</sub></div>
                            <div class="value" id="val-K_I">--</div>
                            <span class="icon">&#9660;</span>
                        </div>
                        <div class="result-item" data-key="fracture_sf" onclick="toggleDerivation('fracture_sf')">
                            <div class="label">Fracture SF</div>
                            <div class="value" id="val-fracture_sf">--</div>
                            <span class="icon">&#9660;</span>
                        </div>
                        <div class="result-item" data-key="a_cr" onclick="toggleDerivation('a_cr')">
                            <div class="label">Critical Crack Size</div>
                            <div class="value" id="val-a_cr">--</div>
                            <span class="icon">&#9660;</span>
                        </div>
                        <div class="result-item" data-key="hoop_stress" onclick="toggleDerivation('hoop_stress')">
                            <div class="label">Hoop Stress</div>
                            <div class="value" id="val-hoop">--</div>
                            <span class="icon">&#9660;</span>
                        </div>
                    </div>

                    <!-- Derivation Panels -->
                    <div class="derivation-panel" id="deriv-K_I">
                        <div class="derivation-header">
                            <span class="derivation-title">Stress Intensity Factor</span>
                            <button class="derivation-close" onclick="toggleDerivation('K_I')">&times;</button>
                        </div>
                        <div class="derivation-step">
                            <div class="step-title">1. General Form</div>
                            <div class="equation">$$ K_I = Y \sigma \sqrt{\pi a} $$</div>
                        </div>
                        <div class="derivation-step">
                            <div class="step-title">2. Substituted Values</div>
                            <div class="equation" id="subst-K_I">Loading...</div>
                        </div>
                    </div>

                    <div class="derivation-panel" id="deriv-fracture_sf">
                        <div class="derivation-header">
                            <span class="derivation-title">Fracture Safety Factor</span>
                            <button class="derivation-close" onclick="toggleDerivation('fracture_sf')">&times;</button>
                        </div>
                        <div class="derivation-step">
                            <div class="step-title">1. Definition</div>
                            <div class="equation">$$ SF = \frac{K_{IC}}{K_I} $$</div>
                        </div>
                        <div class="derivation-step">
                            <div class="step-title">2. Substituted Values</div>
                            <div class="equation" id="subst-fracture_sf">Loading...</div>
                        </div>
                    </div>

                    <div class="derivation-panel" id="deriv-a_cr">
                        <div class="derivation-header">
                            <span class="derivation-title">Critical Crack Size</span>
                            <button class="derivation-close" onclick="toggleDerivation('a_cr')">&times;</button>
                        </div>
                        <div class="derivation-step">
                            <div class="step-title">1. Definition</div>
                            <div class="equation">$$ K_I(a_{cr}) = K_{IC} $$</div>
                        </div>
                        <div class="derivation-step">
                            <div class="step-title">2. Result</div>
                            <div class="equation" id="subst-a_cr">Loading...</div>
                        </div>
                    </div>

                    <div class="derivation-panel" id="deriv-hoop_stress">
                        <div class="derivation-header">
                            <span class="derivation-title">Centrifugal Hoop Stress</span>
                            <button class="derivation-close" onclick="toggleDerivation('hoop_stress')">&times;</button>
                        </div>
                        <div class="derivation-step">
                            <div class="step-title">1. Annular Disk (Shigley)</div>
                            <div class="equation">$$ \sigma_\theta = \frac{3+\nu}{8} \rho \omega^2 \left(r_i^2 + r_o^2 + \frac{r_i^2 r_o^2}{r^2}\right) - \frac{1+3\nu}{8} \rho \omega^2 r^2 $$</div>
                        </div>
                        <div class="derivation-step">
                            <div class="step-title">2. Solid Disk (Shigley)</div>
                            <div class="equation">$$ \sigma_\theta = \frac{3+\nu}{8} \rho \omega^2 r_o^2 - \frac{1+3\nu}{8} \rho \omega^2 r^2 $$</div>
                        </div>
                        <div class="derivation-step">
                            <div class="step-title">3. Thin Ring</div>
                            <div class="equation">$$ \sigma_\theta = \rho \omega^2 r_m^2 $$</div>
                        </div>
                        <div class="derivation-step">
                            <div class="step-title">4. Substituted Values</div>
                            <div class="equation" id="subst-hoop_stress">Loading...</div>
                        </div>
                    </div>

                    <!-- Safety Gauges -->
                    <div class="safety-section" id="safety-section" style="display: none;">
                        <h4>Safety Assessment <span style="font-weight: normal; font-size: 0.8rem; color: var(--text-light);">(click for details)</span></h4>
                        <div class="safety-gauge" onclick="toggleGaugeExplainer('fracture')" style="cursor: pointer;">
                            <div class="gauge-label">Fracture SF</div>
                            <div class="gauge-bar-container">
                                <div class="gauge-bar" id="gauge-fracture-bar"></div>
                                <div class="gauge-threshold" id="gauge-fracture-threshold"></div>
                            </div>
                            <div class="gauge-value" id="gauge-fracture-value">--</div>
                            <span class="icon" style="font-size: 0.7rem; opacity: 0.5;">&#9660;</span>
                        </div>
                        <div class="gauge-explainer" id="explainer-fracture">
                            <div class="explainer-header">
                                <strong>Fracture Safety Factor</strong>
                                <button class="derivation-close" onclick="event.stopPropagation(); toggleGaugeExplainer('fracture')">&times;</button>
                            </div>
                            <p>Ratio of material fracture toughness to applied stress intensity factor.</p>
                            <div class="explainer-equation">$$SF = \frac{K_{IC}}{K_I}$$</div>
                            <div class="explainer-values">
                                <span class="value-tag" id="explainer-fracture-kic">K_IC: --</span>
                                <span class="value-tag" id="explainer-fracture-ki">K_I: --</span>
                                <span class="value-tag" id="explainer-fracture-sf">SF: --</span>
                            </div>
                            <p class="explainer-guidance" id="explainer-fracture-guidance">Guidance will appear here based on your results.</p>
                        </div>

                        <div class="safety-gauge" onclick="toggleGaugeExplainer('life')" style="cursor: pointer;">
                            <div class="gauge-label">Life Fraction</div>
                            <div class="gauge-bar-container">
                                <div class="gauge-bar" id="gauge-life-bar"></div>
                                <div class="gauge-threshold" id="gauge-life-threshold"></div>
                            </div>
                            <div class="gauge-value" id="gauge-life-value">--</div>
                            <span class="icon" style="font-size: 0.7rem; opacity: 0.5;">&#9660;</span>
                        </div>
                        <div class="gauge-explainer" id="explainer-life">
                            <div class="explainer-header">
                                <strong>Remaining Life Fraction</strong>
                                <button class="derivation-close" onclick="event.stopPropagation(); toggleGaugeExplainer('life')">&times;</button>
                            </div>
                            <p>Crack growth life from Paris law integration, then compared to design life.</p>
                            <div id="explainer-life-steps" style="display: none;">
                                <div class="explainer-derivation">
                                    <div style="font-size: 0.8rem; font-weight: 600; color: var(--secondary-color); margin-bottom: 4px;">1. Stress range</div>
                                    <div class="explainer-equation" id="explainer-life-delta-sigma"></div>
                                </div>
                                <div class="explainer-derivation">
                                    <div style="font-size: 0.8rem; font-weight: 600; color: var(--secondary-color); margin-bottom: 4px;">2. Initial stress intensity range</div>
                                    <div class="explainer-equation" id="explainer-life-delta-K"></div>
                                </div>
                                <div class="explainer-derivation">
                                    <div style="font-size: 0.8rem; font-weight: 600; color: var(--secondary-color); margin-bottom: 4px;">3. Initial growth rate</div>
                                    <div class="explainer-equation" id="explainer-life-dadN"></div>
                                </div>
                                <div class="explainer-derivation">
                                    <div style="font-size: 0.8rem; font-weight: 600; color: var(--secondary-color); margin-bottom: 4px;">4. Cycles to failure (numerical integration)</div>
                                    <div class="explainer-equation" id="explainer-life-integral"></div>
                                </div>
                                <div class="explainer-derivation">
                                    <div style="font-size: 0.8rem; font-weight: 600; color: var(--secondary-color); margin-bottom: 4px;">5. Life fraction</div>
                                    <div class="explainer-equation" id="explainer-life-frac-eq"></div>
                                </div>
                            </div>
                            <div class="explainer-values">
                                <span class="value-tag" id="explainer-life-design">Design life: --</span>
                                <span class="value-tag" id="explainer-life-predicted">Predicted: --</span>
                                <span class="value-tag" id="explainer-life-fraction">Fraction: --</span>
                            </div>
                            <p class="explainer-guidance" id="explainer-life-guidance">Guidance will appear here based on your results.</p>
                        </div>
                    </div>

                    <!-- Status Banner -->
                    <div class="status-banner" id="status-banner" style="display: none;">
                        <div class="icon" id="status-icon">&#10003;</div>
                        <div class="content">
                            <h4 id="status-title">Design Status</h4>
                            <p id="status-message">Status message here.</p>
                            <ul class="recommendations" id="recommendations-list"></ul>
                        </div>
                    </div>
                    <div id="export-section" style="display: none; margin-top: 16px;">
                        <button class="btn btn-secondary" id="export-csv-btn" type="button">Export to CSV</button>
                    </div>
                </div>

                <!-- Crack Growth Tab -->
                <div id="crack-growth" class="tab-content">
                    <h3>Fatigue Crack Growth</h3>
                    <div class="results-grid" id="growth-grid" style="display: none;">
                        <div class="result-item highlight" data-key="cycles_to_failure" onclick="toggleDerivation('cycles_to_failure')">
                            <div class="label">Cycles to Failure</div>
                            <div class="value" id="val-cycles">--</div>
                            <span class="icon">&#9660;</span>
                        </div>
                        <div class="result-item">
                            <div class="label">Inspection Interval</div>
                            <div class="value" id="val-inspection">--</div>
                        </div>
                        <div class="result-item">
                            <div class="label">Growth Rate (mm/cycle)</div>
                            <div class="value" id="val-growth-rate">--</div>
                        </div>
                        <div class="result-item" data-key="life_fraction" onclick="toggleDerivation('life_fraction')">
                            <div class="label">Life Fraction Used</div>
                            <div class="value" id="val-life-fraction">--</div>
                            <span class="icon">&#9660;</span>
                        </div>
                    </div>

                    <div class="derivation-panel" id="deriv-cycles_to_failure">
                        <div class="derivation-header">
                            <span class="derivation-title">Paris Law Integration</span>
                            <button class="derivation-close" onclick="toggleDerivation('cycles_to_failure')">&times;</button>
                        </div>
                        <div class="derivation-step">
                            <div class="step-title">1. Paris Law</div>
                            <div class="equation">$$ \frac{da}{dN} = C (\Delta K)^m $$</div>
                        </div>
                        <div class="derivation-step">
                            <div class="step-title">2. Stress Range</div>
                            <div class="equation" id="subst-nf-delta-sigma">Loading...</div>
                        </div>
                        <div class="derivation-step">
                            <div class="step-title">3. Initial Stress Intensity Range</div>
                            <div class="equation" id="subst-nf-delta-K">Loading...</div>
                        </div>
                        <div class="derivation-step">
                            <div class="step-title">4. Initial Growth Rate</div>
                            <div class="equation" id="subst-nf-dadN">Loading...</div>
                        </div>
                        <div class="derivation-step">
                            <div class="step-title">5. Numerical Integration</div>
                            <div class="equation" id="subst-nf-integral">Loading...</div>
                            <p style="margin: 8px 0 0; font-size: 0.85rem; color: var(--text-light);">
                                Because Y(a) changes with crack size, the integral is evaluated
                                numerically using adaptive forward-Euler stepping from a<sub>0</sub>
                                to a<sub>cr</sub>.
                            </p>
                        </div>
                    </div>

                    <div class="derivation-panel" id="deriv-life_fraction">
                        <div class="derivation-header">
                            <span class="derivation-title">Life Fraction Used</span>
                            <button class="derivation-close" onclick="toggleDerivation('life_fraction')">&times;</button>
                        </div>
                        <div class="derivation-step">
                            <div class="step-title">1. Definition</div>
                            <div class="equation">$$ \text{Life fraction} = \frac{N_{design}}{N_f} $$</div>
                            <p style="margin: 8px 0 0; font-size: 0.88rem; color: var(--text-light);">
                                The life fraction compares your required service life (N<sub>design</sub>) to the
                                predicted crack-growth life (N<sub>f</sub>). It answers: <em>what proportion of
                                the component's total crack-growth life does the design life consume?</em>
                            </p>
                        </div>
                        <div class="derivation-step">
                            <div class="step-title">2. Interpretation</div>
                            <ul style="margin: 4px 0 0; font-size: 0.88rem; color: var(--text-light); padding-left: 18px;">
                                <li><strong>&le; 50%</strong> &mdash; Ample margin. The crack would need more than twice the design life to reach critical size. Standard inspection schedules are sufficient.</li>
                                <li><strong>50 &ndash; 100%</strong> &mdash; Marginal. The design life approaches or equals the predicted crack-growth life. Increase inspection frequency and consider reducing operating speed or accepting a smaller initial flaw size.</li>
                                <li><strong>&gt; 100%</strong> &mdash; Insufficient life. The crack is predicted to reach critical size before the design life is reached. The component cannot meet the service target without design changes.</li>
                            </ul>
                        </div>
                        <div class="derivation-step">
                            <div class="step-title">3. Substituted Values</div>
                            <div class="equation" id="subst-life_fraction">Loading...</div>
                        </div>
                    </div>

                    <p id="growth-placeholder" style="color: var(--text-light);">Enter inputs and press Calculate to see crack growth results.</p>

                    <div class="chart-container" id="growth-chart-container" style="display: none;">
                        <h4>Crack Size vs Cycles</h4>
                        <div id="growth-plot" class="chart-plot"></div>
                        <div class="chart-explanation">
                            <strong>What this shows:</strong> Predicted crack growth from initial size to critical size under cyclic centrifugal loading.
                            The inspection interval (N<sub>f</sub>/3) is marked to indicate when NDT should be performed.
                        </div>
                    </div>
                </div>

                <!-- Visualization Tab -->
                <div id="visualization" class="tab-content">
                    <div class="chart-container" style="margin-bottom: 20px;">
                        <h4>Rotor Cross-Section</h4>
                        <svg id="cross-section-svg" viewBox="0 0 760 280" role="img" aria-label="Rotor cross-section with crack location"></svg>
                    </div>
                    <div class="chart-container">
                        <h4>K<sub>I</sub> vs Crack Size</h4>
                        <div id="ki-plot" class="chart-plot"></div>
                        <div class="chart-explanation">
                            <strong>What this shows:</strong> How the stress intensity factor increases with crack size.
                            The horizontal dashed line is K<sub>IC</sub> (fracture toughness). Where K<sub>I</sub> crosses K<sub>IC</sub>,
                            the crack becomes critical.
                        </div>
                    </div>
                </div>

                <!-- Background Tab -->
                <div id="background" class="tab-content">
                    <div class="toc-card">
                        <strong>Contents</strong>
                        <ol>
                            <li><a href="#bg-overview">Overview</a></li>
                            <li><a href="#bg-approach">How to Think About These Problems</a></li>
                            <li><a href="#bg-stress">Centrifugal Stress in Rotating Disks</a></li>
                            <li><a href="#bg-equations">Fracture Mechanics Equations</a></li>
                            <li><a href="#bg-fatigue">Fatigue Crack Growth</a></li>
                            <li><a href="#bg-materials">Material Properties</a></li>
                            <li><a href="#bg-limitations">Limitations &amp; Assumptions</a></li>
                            <li><a href="#bg-references">References</a></li>
                        </ol>
                    </div>

                    <div id="bg-overview" class="bg-section">
                        <h3>1. Overview</h3>
                        <p>
                            This tool applies <strong>Linear Elastic Fracture Mechanics (LEFM)</strong> to assess whether a pre-existing
                            crack in a rotating composite component will propagate to failure. It addresses a common question in
                            rotating machinery design: <em>given a known or assumed defect, is the component safe to operate, and
                            for how long?</em>
                        </p>
                        <p>
                            Real composite components &mdash; flywheel rims, compressor impellers, centrifuge rotors, turbine
                            blades &mdash; inevitably contain manufacturing defects: voids, delaminations, fiber misalignment, or
                            matrix micro-cracks. Rather than assuming these defects do not exist, damage-tolerant design accepts
                            their presence and asks whether they will grow to a dangerous size within the service life.
                        </p>
                        <div class="callout-info">
                            <strong>Static fracture check:</strong> Compares the applied stress intensity factor K<sub>I</sub>
                            to the material's fracture toughness K<sub>IC</sub>. If K<sub>I</sub> &ge; K<sub>IC</sub>, immediate
                            brittle fracture is predicted.
                        </div>
                        <div class="callout-info">
                            <strong>Fatigue crack growth:</strong> Integrates the Paris law da/dN = C(&Delta;K)<sup>m</sup> from the
                            initial crack size to the critical crack size, yielding the number of load cycles to failure and a
                            recommended inspection interval.
                        </div>
                    </div>

                    <div id="bg-approach" class="bg-section">
                        <h3>2. How to Think About These Problems</h3>
                        <p>
                            A fracture mechanics assessment follows a logical chain. Each link feeds the next, and
                            understanding the chain helps you interpret the results and know which inputs matter most.
                        </p>

                        <h4>Step 1: Determine the Stress Field</h4>
                        <p>
                            Before asking whether a crack is dangerous, you need to know the stress at the crack location. For
                            a rotating disk, centrifugal body forces produce a stress field that varies with radius. The hoop
                            (tangential) stress is usually the dominant driver because it acts to open radial cracks &mdash; the
                            most common orientation in rotors. This tool computes hoop and radial stress from the Shigley
                            closed-form rotating-disk equations (see Section 3).
                        </p>

                        <h4>Step 2: Compute the Stress Intensity Factor</h4>
                        <p>
                            The stress intensity factor K<sub>I</sub> quantifies how severely a crack amplifies the
                            surrounding stress field. It depends on three things: the far-field stress &sigma;, the crack
                            size <em>a</em>, and a dimensionless geometry correction factor <em>Y</em> that accounts for the
                            crack shape and the component's finite width. A larger crack or higher stress both increase
                            K<sub>I</sub>.
                        </p>

                        <h4>Step 3: Compare to Fracture Toughness</h4>
                        <p>
                            The material's fracture toughness K<sub>IC</sub> is the critical value of K<sub>I</sub> at which
                            unstable (fast) fracture occurs. The ratio K<sub>IC</sub>&thinsp;/&thinsp;K<sub>I</sub> is the
                            fracture safety factor. Values above the required target (commonly 2.0&ndash;3.0 for rotating
                            equipment) indicate the crack is stable at its current size. A safety factor below 1.0 means
                            the crack has already reached or exceeded the critical condition.
                        </p>

                        <h4>Step 4: Predict Crack Growth Life</h4>
                        <p>
                            Even when K<sub>I</sub> &lt; K<sub>IC</sub>, cyclic loading causes the crack to grow slowly. The
                            Paris law describes this sub-critical growth rate. By integrating from the initial crack size to
                            the critical size, you obtain the number of cycles to failure N<sub>f</sub>. Dividing N<sub>f</sub>
                            by an appropriate safety factor (typically 3) yields a recommended inspection interval &mdash; the
                            point at which you should re-inspect the component via NDT to verify the crack has not exceeded
                            expectations.
                        </p>

                        <h4>What Drives the Answer?</h4>
                        <div class="callout-info">
                            <strong>Sensitivity insight:</strong> K<sub>I</sub> scales with &radic;a, so doubling the crack size
                            increases K<sub>I</sub> by about 40%. Hoop stress scales with &omega;&sup2; (and therefore RPM&sup2;), so a
                            modest speed increase can dramatically raise K<sub>I</sub>. When in doubt, the two most impactful
                            inputs are <strong>rotational speed</strong> and <strong>initial crack size</strong>.
                        </div>
                        <div class="callout-warning">
                            <strong>Choosing the initial crack size:</strong> Use the largest defect that could escape your
                            inspection process. For ultrasonic NDT on composites, a typical detectable flaw size is
                            0.5&ndash;2 mm depending on the method and component geometry. If no inspection is planned,
                            assume worst-case manufacturing defects from coupon testing or industry standards.
                        </div>
                    </div>

                    <div id="bg-stress" class="bg-section">
                        <h3>3. Centrifugal Stress in Rotating Disks</h3>
                        <p>
                            A spinning disk experiences centrifugal body forces that produce both hoop (tangential) and radial
                            stress components. These stresses depend on the disk geometry, material density, Poisson's ratio,
                            and angular velocity. The closed-form solutions below assume a uniform-density, constant-thickness
                            disk (Shigley, Ch. 3).
                        </p>

                        <div class="equation-card">
                            <strong>Annular Disk &mdash; Hoop Stress</strong>
                            <span class="equation-expression">$$ \sigma_\theta = \frac{3+\nu}{8}\,\rho\,\omega^2 \!\left(r_i^2 + r_o^2 + \frac{r_i^2\,r_o^2}{r^2}\right) - \frac{1+3\nu}{8}\,\rho\,\omega^2\,r^2 $$</span>
                            <ul>
                                <li>r<sub>i</sub>, r<sub>o</sub> &mdash; inner and outer radii</li>
                                <li>r &mdash; radius at which stress is evaluated</li>
                                <li>&nu; &mdash; Poisson's ratio</li>
                                <li>&rho; &mdash; material density</li>
                                <li>&omega; = 2&pi; &middot; RPM / 60 &mdash; angular velocity (rad/s)</li>
                            </ul>
                        </div>

                        <div class="equation-card">
                            <strong>Annular Disk &mdash; Radial Stress</strong>
                            <span class="equation-expression">$$ \sigma_r = \frac{3+\nu}{8}\,\rho\,\omega^2 \!\left(r_i^2 + r_o^2 - \frac{r_i^2\,r_o^2}{r^2} - r^2\right) $$</span>
                        </div>

                        <div class="equation-card">
                            <strong>Solid Disk (r<sub>i</sub> = 0)</strong>
                            <span class="equation-expression">$$ \sigma_\theta = \frac{3+\nu}{8}\,\rho\,\omega^2\,r_o^2 - \frac{1+3\nu}{8}\,\rho\,\omega^2\,r^2 $$</span>
                            <span class="equation-expression">$$ \sigma_r = \frac{3+\nu}{8}\,\rho\,\omega^2 \!\left(r_o^2 - r^2\right) $$</span>
                        </div>

                        <div class="equation-card">
                            <strong>Thin Ring</strong>
                            <span class="equation-expression">$$ \sigma_\theta = \rho\,\omega^2\,r_m^2 \qquad\text{where}\quad r_m = \tfrac{1}{2}(r_i + r_o) $$</span>
                            <p style="margin-top: 6px; font-size: 0.9rem; color: var(--text-light);">
                                The thin-ring approximation ignores radial variation and is valid when the wall thickness
                                is small relative to the mean radius (t/r<sub>m</sub> &lt; 0.1).
                            </p>
                        </div>

                        <p>
                            Key behavior: hoop stress in an annular disk is <em>highest at the inner bore</em> and decreases
                            toward the outer rim. Radial stress peaks somewhere in the interior and is zero at both the inner
                            and outer free surfaces. For crack assessment, the hoop stress at the crack's radial location is
                            what drives K<sub>I</sub> for radial cracks.
                        </p>
                    </div>

                    <div id="bg-equations" class="bg-section">
                        <h3>4. Fracture Mechanics Equations</h3>

                        <div class="equation-card">
                            <strong>Stress Intensity Factor</strong>
                            <span class="equation-expression">$$ K_I = Y \,\sigma \sqrt{\pi a} $$</span>
                            <ul>
                                <li>Y &mdash; geometry correction factor (depends on crack type and a/W ratio)</li>
                                <li>&sigma; &mdash; far-field centrifugal hoop stress at the crack location</li>
                                <li>a &mdash; crack half-length (through/embedded) or depth (edge/surface)</li>
                                <li>W &mdash; ligament width (component thickness for radial cracks, radial width for circumferential)</li>
                            </ul>
                            <p style="margin-top: 6px; font-size: 0.9rem; color: var(--text-light);">
                                K<sub>I</sub> characterizes the singular stress field near the crack tip. It is the single
                                parameter that governs whether a crack will extend &mdash; regardless of the specific loading
                                and geometry that produced it.
                            </p>
                        </div>

                        <div class="equation-card">
                            <strong>Fracture Safety Factor</strong>
                            <span class="equation-expression">$$ SF = \frac{K_{IC}}{K_I} $$</span>
                            <ul>
                                <li>K<sub>IC</sub> &mdash; mode-I plane-strain fracture toughness (a material property)</li>
                                <li>SF &ge; required value &Rightarrow; acceptable; SF &lt; 1 &Rightarrow; fracture predicted</li>
                            </ul>
                            <p style="margin-top: 6px; font-size: 0.9rem; color: var(--text-light);">
                                The required safety factor depends on consequence of failure and confidence in inputs.
                                Typical values: 2.0 for well-characterized materials with regular inspection, up to 4.0
                                for critical applications with limited testing data.
                            </p>
                        </div>

                        <div class="equation-card">
                            <strong>Critical Crack Size</strong>
                            <span class="equation-expression">$$ K_I(a_{cr}) = K_{IC} \quad\Rightarrow\quad a_{cr} = \frac{1}{\pi}\!\left(\frac{K_{IC}}{Y\,\sigma}\right)^{\!2} $$</span>
                            <p style="margin-top: 6px; font-size: 0.9rem; color: var(--text-light);">
                                The critical crack size is solved iteratively because the geometry factor Y itself depends on
                                crack size. The simplified form above applies when Y is approximately constant.
                            </p>
                        </div>

                        <h4>Geometry Factors Y(a/W)</h4>
                        <p>
                            The geometry factor corrects K<sub>I</sub> for the finite size of the component and the shape of
                            the crack. As a/W approaches 1 (crack nearly through the full ligament), Y increases rapidly,
                            reflecting the stress amplification from the diminishing remaining material.
                        </p>
                        <div class="equation-card">
                            <strong>Through Crack (Feddersen/Tada)</strong>
                            <span class="equation-expression">$$ Y = \sqrt{\sec\left(\frac{\pi a}{2W}\right)} $$</span>
                            <p style="margin-top: 6px; font-size: 0.9rem; color: var(--text-light);">
                                Valid for a central crack of total length 2a in a plate of width 2W under uniform tension.
                                Accuracy within 0.3% for a/W &lt; 0.35.
                            </p>
                        </div>
                        <div class="equation-card">
                            <strong>Edge Crack (Tada polynomial)</strong>
                            <span class="equation-expression">$$ Y = 1.12 - 0.231\frac{a}{W} + 10.55\left(\frac{a}{W}\right)^2 - 21.72\left(\frac{a}{W}\right)^3 + 30.39\left(\frac{a}{W}\right)^4 $$</span>
                            <p style="margin-top: 6px; font-size: 0.9rem; color: var(--text-light);">
                                Single edge crack of depth a in a plate of width W. The leading coefficient 1.12 reflects
                                the free-surface correction. Valid for a/W &lt; 0.6.
                            </p>
                        </div>
                        <div class="equation-card">
                            <strong>Surface Crack (Newman-Raju simplified, a/c = 1)</strong>
                            <span class="equation-expression">$$ Y \approx 0.728 $$</span>
                            <p style="margin-top: 6px; font-size: 0.9rem; color: var(--text-light);">
                                Semicircular surface flaw (a/c = 1) at the deepest point. For non-semicircular shapes
                                (a/c &ne; 1), the full Newman-Raju parametric equations should be used.
                            </p>
                        </div>
                        <div class="equation-card">
                            <strong>Embedded / Penny-shaped Crack</strong>
                            <span class="equation-expression">$$ Y = \frac{2}{\pi} \approx 0.637 $$</span>
                            <p style="margin-top: 6px; font-size: 0.9rem; color: var(--text-light);">
                                Circular (penny-shaped) embedded crack in an infinite body. The lowest Y of common
                                crack types because the crack tip is fully surrounded by material.
                            </p>
                        </div>

                        <div class="equation-card">
                            <strong>Elliptical Surface Crack (Newman-Raju, NASA TM-85793)</strong>
                            <span class="equation-expression">$$ Y = \frac{F}{\sqrt{Q}} $$</span>
                            <span class="equation-expression">$$ Q = 1 + 1.464\left(\frac{a}{c}\right)^{1.65} \quad\text{for } a/c \le 1 $$</span>
                            <span class="equation-expression">$$ F = (M_1 + M_2\,\alpha^2 + M_3\,\alpha^4)\,f_w $$</span>
                            <ul>
                                <li>a &mdash; crack depth; c &mdash; half surface length; &alpha; = a/W</li>
                                <li>M<sub>1</sub> = 1.13 &minus; 0.09(a/c)</li>
                                <li>M<sub>2</sub> = &minus;0.54 + 0.89 / (0.2 + a/c)</li>
                                <li>M<sub>3</sub> = 0.5 &minus; 1/(0.65 + a/c) + 14(1 &minus; a/c)<sup>24</sup></li>
                                <li>f<sub>w</sub> = &radic;(sec(&radic;&alpha; &middot; &pi;/2)) &mdash; finite-width correction</li>
                            </ul>
                            <p style="margin-top: 6px; font-size: 0.9rem; color: var(--text-light);">
                                <strong>Applicability:</strong> Most common real-world flaw shape. Manufacturing defects, porosity,
                                delamination origins. Reduces to Y &asymp; 0.728 at a/c = 1 (semicircular).
                            </p>
                            <p style="margin-top: 4px; font-size: 0.9rem; color: var(--text-light);">
                                <strong>Examples:</strong> Composite layup voids, fiber breakage zones, impact damage sites.
                            </p>
                        </div>

                        <div class="equation-card">
                            <strong>Corner Crack (Quarter-Elliptical)</strong>
                            <span class="equation-expression">$$ Y_{corner} = Y_{surface} \times (1.1 + 0.1\,\alpha) $$</span>
                            <ul>
                                <li>Y<sub>surface</sub> from the Newman-Raju elliptical surface formula above</li>
                                <li>&alpha; = a/W &mdash; crack depth ratio</li>
                                <li>Corner correction factor accounts for the additional free surface at the corner</li>
                            </ul>
                            <p style="margin-top: 6px; font-size: 0.9rem; color: var(--text-light);">
                                <strong>Applicability:</strong> Cracks initiating at geometric transitions &mdash; holes, fillets, shoulders.
                                Y is 10&ndash;20% higher than the equivalent surface crack due to the additional free-surface effect.
                            </p>
                            <p style="margin-top: 4px; font-size: 0.9rem; color: var(--text-light);">
                                <strong>Examples:</strong> Bolt holes in composite flanges, corner of rectangular cutouts,
                                fillets at disk-to-shaft transitions.
                            </p>
                        </div>

                        <div class="equation-card">
                            <strong>Double Edge Crack (Tada/Isida)</strong>
                            <span class="equation-expression">$$ Y = 1.122 - 0.561\frac{a}{W} - 0.205\left(\frac{a}{W}\right)^2 + 0.471\left(\frac{a}{W}\right)^3 - 0.190\left(\frac{a}{W}\right)^4 $$</span>
                            <ul>
                                <li>a &mdash; crack depth (each side); W &mdash; half-width of specimen</li>
                                <li>Valid for a/W &lt; 0.7</li>
                            </ul>
                            <p style="margin-top: 6px; font-size: 0.9rem; color: var(--text-light);">
                                <strong>Applicability:</strong> Symmetric edge flaws in flat specimens or thin sections.
                                Better validity range than single-edge for symmetric loading configurations.
                            </p>
                            <p style="margin-top: 4px; font-size: 0.9rem; color: var(--text-light);">
                                <strong>Examples:</strong> Double-notch tensile specimens, symmetric machining damage,
                                edge delaminations on both sides of a composite panel.
                            </p>
                        </div>
                    </div>

                    <div id="bg-fatigue" class="bg-section">
                        <h3>5. Fatigue Crack Growth</h3>
                        <p>
                            Even when K<sub>I</sub> is well below K<sub>IC</sub>, cyclic loading causes the crack to extend
                            incrementally with each load cycle. The Paris-Erdogan law describes the stable (Region II) growth
                            rate as a power-law function of the stress intensity factor range:
                        </p>
                        <div class="equation-card">
                            <strong>Paris Law</strong>
                            <span class="equation-expression">$$ \frac{da}{dN} = C \left(\Delta K\right)^m $$</span>
                            <ul>
                                <li>C, m &mdash; experimentally determined material constants</li>
                                <li>&Delta;K = K<sub>max</sub> &minus; K<sub>min</sub> = (1 &minus; R) &middot; K<sub>max</sub></li>
                                <li>R = &sigma;<sub>min</sub> / &sigma;<sub>max</sub> &mdash; stress ratio</li>
                            </ul>
                        </div>
                        <p>
                            The total number of cycles to failure is obtained by integrating the Paris law from the initial
                            crack size a<sub>0</sub> to the critical crack size a<sub>cr</sub>:
                        </p>
                        <div class="equation-card">
                            <strong>Cycles to Failure</strong>
                            <span class="equation-expression">$$ N_f = \int_{a_0}^{a_{cr}} \frac{da}{C\left(\Delta K(a)\right)^m} $$</span>
                            <p style="margin-top: 6px; font-size: 0.9rem; color: var(--text-light);">
                                This integral is evaluated numerically because &Delta;K(a) = Y(a)&thinsp;&Delta;&sigma;&thinsp;&radic;(&pi;a)
                                changes with crack size through both the &radic;a term and the geometry factor Y(a).
                            </p>
                        </div>

                        <h4>Inspection Interval</h4>
                        <p>
                            The recommended inspection interval is N<sub>f</sub>&thinsp;/&thinsp;3. This factor of 3 provides
                            margin for uncertainties in the Paris law constants, crack measurement accuracy, and load
                            estimation. In practice, the interval should be validated against the specific NDT method's
                            probability of detection (POD) curve and any regulatory requirements.
                        </p>

                        <h4>Stress Ratio Effects</h4>
                        <p>
                            The stress ratio R affects crack growth through its influence on &Delta;K. For a rotating component
                            that spins up from rest each cycle, R = 0 (zero-to-max loading). If the component maintains a
                            minimum speed during operation, R &gt; 0 and &Delta;K is reduced, slowing crack growth. This tool
                            uses the basic Paris model with &Delta;K = (1&minus;R)&middot;K<sub>max</sub> for the stress range reduction.
                        </p>
                    </div>

                    <div id="bg-materials" class="bg-section">
                        <h3>6. Material Properties</h3>
                        <p>Preset materials and their fracture properties used in this tool:</p>
                        <div id="material-table-container"></div>

                        <h4>Interpreting Material Properties</h4>
                        <ul>
                            <li><strong>K<sub>IC</sub></strong> (fracture toughness) &mdash; Higher is better. Carbon fiber composites have
                                substantially higher toughness than short-fiber-filled polymers, reflecting the energy absorbed by fiber
                                pullout and bridging during crack propagation.</li>
                            <li><strong>Paris C</strong> &mdash; Sets the baseline crack growth rate. Smaller values (e.g., 1e-10) mean
                                slower growth per cycle. C has units that depend on m, so values cannot be compared across different m exponents.</li>
                            <li><strong>Paris m</strong> &mdash; Controls the sensitivity of growth rate to &Delta;K. Higher m (4&ndash;6
                                for polymers) means crack growth accelerates more steeply as the crack lengthens, leaving less warning
                                before failure.</li>
                            <li><strong>&rho;</strong> (density) &mdash; Directly affects centrifugal stress. Lower density is advantageous
                                for rotors because it reduces the body force at any given speed.</li>
                            <li><strong>&sigma;<sub>uts</sub></strong> (ultimate tensile strength) &mdash; Used for reference only in
                                this tool; the fracture assessment is entirely K-based, not strength-based.</li>
                        </ul>

                        <div class="callout-warning">
                            <strong>Note:</strong> Paris law constants are approximate and can vary significantly with
                            fiber orientation, temperature, frequency, and environment. Always use test data for critical applications.
                            The values here are representative of room-temperature, laboratory-air conditions at moderate frequencies (1&ndash;10 Hz).
                        </div>
                    </div>

                    <div id="bg-limitations" class="bg-section">
                        <h3>7. Limitations &amp; Assumptions</h3>
                        <ul>
                            <li><strong>LEFM validity:</strong> Assumes small-scale yielding &mdash; the plastic (or damage) zone at the
                                crack tip must be small relative to the crack length, ligament width, and component thickness. Most
                                fiber-reinforced composites satisfy this condition due to their brittle matrix behavior.</li>
                            <li><strong>Idealized crack geometry:</strong> Geometry factors are for canonical crack shapes (through, edge,
                                surface, embedded, elliptical surface, corner, double edge) in flat plates. Real defects in curved rotors
                                may differ; consult FEA-based K solutions for critical designs.</li>
                            <li><strong>Isotropic material model:</strong> Composite materials are treated as effectively isotropic. This
                                is a reasonable first approximation for quasi-isotropic layups or short-fiber composites, but
                                underestimates the directional dependence in strongly anisotropic layups (e.g., unidirectional or
                                hoop-wound composites where delamination toughness differs from transverse toughness).</li>
                            <li><strong>Constant-amplitude loading:</strong> The Paris law integration assumes each cycle applies the same
                                &Delta;&sigma;. Variable-amplitude loading (e.g., different operating speeds) requires cycle-counting
                                methods such as rainflow counting and Miner's rule.</li>
                            <li><strong>No threshold or closure effects:</strong> The tool does not model the fatigue threshold
                                &Delta;K<sub>th</sub> below which cracks do not grow, nor crack closure effects that reduce the
                                effective &Delta;K. This makes predictions conservative for low-R, low-&Delta;K conditions.</li>
                            <li><strong>Uniform disk geometry:</strong> Centrifugal stress uses Shigley closed-form equations for
                                uniform-density, constant-thickness disks. Profiled disks, bladed rotors, or non-uniform density
                                distributions require FEA.</li>
                            <li><strong>No environmental effects:</strong> Stress corrosion cracking, moisture absorption in composites,
                                and elevated-temperature effects are not modeled. These can significantly accelerate crack growth in
                                service.</li>
                        </ul>
                    </div>

                    <div id="bg-references" class="bg-section">
                        <h3>8. References</h3>
                        <ul>
                            <li>T.L. Anderson, <em>Fracture Mechanics: Fundamentals and Applications</em>, 4th ed., CRC Press, 2017
                                &mdash; Comprehensive treatment of LEFM, EPFM, and fatigue crack growth. Chapters 2 and 10 are
                                directly relevant.</li>
                            <li>H. Tada, P.C. Paris & G.R. Irwin, <em>The Stress Analysis of Cracks Handbook</em>, 3rd ed., ASME Press, 2000
                                &mdash; Standard reference for stress intensity factor solutions by crack/geometry type.</li>
                            <li>P. Paris & F. Erdogan, "A Critical Analysis of Crack Propagation Laws", <em>J. Basic Eng.</em>, vol. 85,
                                pp. 528&ndash;534, 1963 &mdash; Original paper establishing the power-law fatigue crack growth relationship.</li>
                            <li>J.C. Newman & I.S. Raju, "Stress Intensity Factor Equations for Cracks in Three-Dimensional Finite Bodies
                                Subjected to Tension and Bending Loads", NASA TM-85793, 1984 &mdash; Parametric SIF equations for surface
                                and corner cracks widely used in aerospace damage tolerance.</li>
                            <li>R.G. Budynas & J.K. Nisbett, <em>Shigley's Mechanical Engineering Design</em>, 11th ed., McGraw-Hill, 2020
                                &mdash; Rotating disk stress equations (Ch. 3) used for centrifugal hoop and radial stress computation.</li>
                            <li>ASTM E399-22, "Standard Test Method for Linear-Elastic Plane-Strain Fracture Toughness of Metallic Materials"
                                &mdash; Defines K<sub>IC</sub> testing methodology; adapted procedures exist for polymer composites.</li>
                            <li>ASTM E647-23, "Standard Test Method for Measurement of Fatigue Crack Growth Rates"
                                &mdash; Standard method for determining da/dN vs. &Delta;K and the Paris law constants C and m.</li>
                        </ul>
                    </div>
                </div>

                <!-- Sensitivity Tab -->
                <div id="sensitivity" class="tab-content">
                    <h3>Parameter Sensitivity Study</h3>
                    <p id="sensitivity-placeholder" style="color: var(--text-light);">
                        Run a baseline calculation first, then sweep a parameter to see how results change.
                    </p>

                    <div class="sensitivity-controls" id="sensitivity-controls" style="display: none;">
                        <div class="input-row" style="align-items: end;">
                            <div class="input-group" style="flex: 2;">
                                <label for="sweep-param">Parameter to Sweep</label>
                                <select id="sweep-param">
                                    <optgroup label="Numeric Parameters">
                                        <option value="initial_crack_size_mm">Initial Crack Size (mm)</option>
                                        <option value="speed_rpm">Speed (RPM)</option>
                                        <option value="stress_ratio_R">Stress Ratio (R)</option>
                                        <option value="fracture_toughness">Fracture Toughness K_IC</option>
                                        <option value="paris_C">Paris C</option>
                                        <option value="paris_m">Paris m</option>
                                        <option value="thickness_mm">Thickness (mm)</option>
                                        <option value="crack_location_radius_mm">Crack Location Radius (mm)</option>
                                        <option value="crack_aspect_ratio">Crack Aspect Ratio (a/c)</option>
                                    </optgroup>
                                    <optgroup label="Categorical Parameters">
                                        <option value="crack_type">Crack Type</option>
                                        <option value="crack_orientation">Crack Orientation</option>
                                        <option value="geometry_type">Geometry Type</option>
                                    </optgroup>
                                </select>
                            </div>
                            <div id="sweep-numeric-controls" style="display: contents;">
                                <div class="input-group">
                                    <label for="sweep-min">Min</label>
                                    <input type="number" id="sweep-min" step="any">
                                </div>
                                <div class="input-group">
                                    <label for="sweep-max">Max</label>
                                    <input type="number" id="sweep-max" step="any">
                                </div>
                                <div class="input-group" style="max-width: 80px;">
                                    <label for="sweep-steps">Points</label>
                                    <input type="number" id="sweep-steps" value="20" min="5" max="100" step="1">
                                </div>
                            </div>
                        </div>
                        <button type="button" class="btn btn-primary" id="run-sweep-btn" style="margin-top: 12px;">Run Sweep</button>

                        <div class="sweep-progress" id="sweep-progress" style="display: none; margin-top: 12px;">
                            <div class="sweep-progress-bar">
                                <div class="sweep-progress-fill" id="sweep-progress-fill" style="width: 0%;"></div>
                            </div>
                            <span class="sweep-progress-text" id="sweep-progress-text">0 / 20</span>
                        </div>
                    </div>

                    <div id="sensitivity-plots" style="display: none; margin-top: 20px;">
                        <div class="chart-container" style="margin-bottom: 16px;">
                            <h4>Fracture Safety Factor</h4>
                            <div id="sensitivity-sf-plot" class="chart-plot"></div>
                        </div>
                        <div class="chart-container" style="margin-bottom: 16px;">
                            <h4>Cycles to Failure</h4>
                            <div id="sensitivity-nf-plot" class="chart-plot"></div>
                        </div>
                        <div class="chart-container">
                            <h4>Life Fraction Used</h4>
                            <div id="sensitivity-life-plot" class="chart-plot"></div>
                        </div>
                    </div>
                </div>
            </section>
        </div>
    </main>

    <footer class="footer">
        <p>&copy; 2025 Engineering Tools. All tools are for educational purposes. <a class="support-link" href="https://ko-fi.com/transparent_tools" target="_blank" rel="noopener">Support on Ko-fi</a></p>
    </footer>

    <script>
        // =================================================================
        // 0. GLOBAL STORE & CONFIG
        // =================================================================
        let toolDocumentation = {};
        let pyUtils, pyToolModule;
        let lastResults = null;
        let openDerivation = null;
        let openExplainer = null;

        const TOOL_MODULE_NAME = 'fracture_mechanics';
        const TOOL_FUNCTION_NAME = 'analyze_fracture_and_crack_growth';
        const STORAGE_KEY = 'composite-fracture-analyzer-settings';

        const FRACTURE_MATERIALS = {
            cfrp_hoop_wound: { display_name: "Carbon Fiber / Epoxy (Hoop-wound)", K_IC: 35.0, paris_C: 1e-10, paris_m: 3.5, density: 1600, sigma_uts: 1500 },
            gfrp_epoxy: { display_name: "Glass Fiber / Epoxy", K_IC: 20.0, paris_C: 5e-9, paris_m: 4.0, density: 2000, sigma_uts: 800 },
            aramid_epoxy: { display_name: "Aramid / Epoxy (Kevlar)", K_IC: 25.0, paris_C: 3e-9, paris_m: 3.8, density: 1380, sigma_uts: 1100 },
            pa6_gf30: { display_name: "30% Glass-filled Nylon (PA6-GF30)", K_IC: 7.0, paris_C: 5e-8, paris_m: 5.0, density: 1360, sigma_uts: 180 },
            peek_cf30: { display_name: "30% Carbon-filled PEEK (PEEK-CF30)", K_IC: 6.5, paris_C: 2e-9, paris_m: 4.0, density: 1410, sigma_uts: 212 },
            generic_polymer: { display_name: "Generic Isotropic Polymer", K_IC: 3.0, paris_C: 1e-7, paris_m: 5.5, density: 1200, sigma_uts: 60 },
        };

        const defaultSettings = {
            expertMode: false,
            showDerivations: false,
            showGauges: false,
            theme: 'system',
            density: 'comfortable',
            precision: 3
        };
        let settings = { ...defaultSettings };

        // =================================================================
        // SETTINGS MANAGEMENT
        // =================================================================
        function saveSettings() { localStorage.setItem(STORAGE_KEY, JSON.stringify(settings)); }

        function loadSettings() {
            const stored = localStorage.getItem(STORAGE_KEY);
            if (!stored) { settings = { ...defaultSettings }; return; }
            try { settings = { ...defaultSettings, ...JSON.parse(stored) }; }
            catch (e) { settings = { ...defaultSettings }; }
        }

        function applySettings() {
            document.body.dataset.theme = settings.theme;
            document.body.dataset.density = settings.density;
            applyExpertMode();
            document.getElementById('setting-show-derivations').checked = settings.showDerivations;
            document.getElementById('setting-show-gauges').checked = settings.showGauges;
            setSegmentedActive('[data-theme]', settings.theme, 'theme');
            setSegmentedActive('[data-density]', settings.density, 'density');
            setSegmentedActive('[data-precision]', String(settings.precision), 'precision');
            if (lastResults) displayResults(lastResults, parseFloat(document.getElementById('required_fracture_sf').value));
            renderCrossSectionPreview();
            renderCrackTypeDiagram();
            renderCrackOrientationDiagram();
        }

        function setSegmentedActive(selector, value, dataAttr) {
            document.querySelectorAll(`.settings-panel ${selector}`).forEach(btn => {
                const isActive = btn.dataset[dataAttr] === value;
                btn.classList.toggle('active', isActive);
                btn.setAttribute('aria-pressed', isActive ? 'true' : 'false');
            });
        }

        function handleSettingChange(key, value) { settings[key] = value; saveSettings(); applySettings(); }

        function toggleSettingsPanel(open) {
            const panel = document.getElementById('settings-panel');
            const overlay = document.getElementById('settings-overlay');
            const isOpen = open ?? !panel.classList.contains('open');
            panel.classList.toggle('open', isOpen);
            overlay.classList.toggle('open', isOpen);
            panel.setAttribute('aria-hidden', isOpen ? 'false' : 'true');
            overlay.setAttribute('aria-hidden', isOpen ? 'false' : 'true');
        }

        function bindSettingsControls() {
            document.getElementById('setting-show-derivations').addEventListener('change', e => handleSettingChange('showDerivations', e.target.checked));
            document.getElementById('setting-show-gauges').addEventListener('change', e => handleSettingChange('showGauges', e.target.checked));
            document.querySelectorAll('.settings-panel [data-theme]').forEach(btn => btn.addEventListener('click', () => handleSettingChange('theme', btn.dataset.theme)));
            document.querySelectorAll('.settings-panel [data-density]').forEach(btn => btn.addEventListener('click', () => handleSettingChange('density', btn.dataset.density)));
            document.querySelectorAll('.settings-panel [data-precision]').forEach(btn => btn.addEventListener('click', () => handleSettingChange('precision', Number(btn.dataset.precision))));
            document.getElementById('settings-reset').addEventListener('click', () => { settings = { ...defaultSettings }; saveSettings(); applySettings(); });
            document.getElementById('settings-button').addEventListener('click', () => toggleSettingsPanel(true));
            document.getElementById('settings-close').addEventListener('click', () => toggleSettingsPanel(false));
            document.getElementById('settings-overlay').addEventListener('click', () => toggleSettingsPanel(false));
            document.addEventListener('keydown', e => { if (e.key === 'Escape') toggleSettingsPanel(false); });
        }

        // =================================================================
        // FORMATTING
        // =================================================================
        function formatNumber(value, overridePrecision = null) {
            if (!Number.isFinite(value)) return 'N/A';
            const precision = overridePrecision ?? settings.precision;
            return value.toFixed(precision);
        }

        function formatCycles(value) {
            if (!Number.isFinite(value)) return 'Infinite';
            if (value >= 1e6) return (value / 1e6).toFixed(1) + 'M';
            if (value >= 1e3) return (value / 1e3).toFixed(1) + 'k';
            return Math.round(value).toLocaleString();
        }

        // =================================================================
        // CROSS-SECTION PREVIEW
        // =================================================================
        function buildSectionPolygon(sideSign, rStartMm, rEndMm, thicknessMm, centerX, centerY, scalePxPerMm) {
            if (rEndMm <= rStartMm) return '';
            const yTop = centerY - 0.5 * thicknessMm * scalePxPerMm;
            const yBottom = centerY + 0.5 * thicknessMm * scalePxPerMm;
            const xInner = centerX + sideSign * rStartMm * scalePxPerMm;
            const xOuter = centerX + sideSign * rEndMm * scalePxPerMm;
            return [
                `${xInner.toFixed(2)},${yTop.toFixed(2)}`,
                `${xOuter.toFixed(2)},${yTop.toFixed(2)}`,
                `${xOuter.toFixed(2)},${yBottom.toFixed(2)}`,
                `${xInner.toFixed(2)},${yBottom.toFixed(2)}`
            ].join(' ');
        }

        function renderCrossSectionPreview() {
            const svg = document.getElementById('cross-section-svg');
            if (!svg) return;

            const isDark = document.body.dataset.theme === 'dark' ||
                (document.body.dataset.theme === 'system' && window.matchMedia('(prefers-color-scheme: dark)').matches);

            const colors = {
                bg: isDark ? '#111827' : '#ffffff',
                disk: isDark ? '#334155' : '#d7dde8',
                stroke: isDark ? '#94a3b8' : '#111827',
                axis: isDark ? '#64748b' : '#64748b',
                axisText: isDark ? '#94a3b8' : '#475569',
                outerR: isDark ? '#34d399' : '#0f766e',
                innerR: isDark ? '#fbbf24' : '#b45309',
                thickness: isDark ? '#e5e7eb' : '#111827',
                crack: isDark ? '#f87171' : '#dc2626',
                crackLoc: isDark ? '#60a5fa' : '#2563eb',
                bore: isDark ? 'rgba(17,24,39,0.85)' : 'rgba(255,255,255,0.92)',
                boreBorder: isDark ? '#475569' : '#cbd5e1',
            };

            const geom = document.getElementById('geometry_type').value;
            const outerR = Math.max(0.1, parseFloat(document.getElementById('outer_radius_mm').value) || 100);
            const innerR = geom === 'solid_disk' ? 0 : Math.max(0, parseFloat(document.getElementById('inner_radius_mm').value) || 0);
            const thickness = Math.max(0.1, parseFloat(document.getElementById('thickness_mm').value) || 10);
            const crackLocR = Math.max(0, parseFloat(document.getElementById('crack_location_radius_mm').value) || 30);
            const crackSize = Math.max(0, parseFloat(document.getElementById('initial_crack_size_mm').value) || 1);
            const crackType = document.getElementById('crack_type').value;

            const w = 760, h = 280;
            const marginX = 50;
            const centerX = w / 2;
            const centerY = h / 2;
            const scalePxPerMm = (0.5 * w - marginX) / Math.max(outerR, 1);

            const radialMarkerY = h - 28;

            // Build disk polygons (left & right halves)
            const sidePolygons = [];
            for (const side of [1, -1]) {
                const points = buildSectionPolygon(side, innerR, outerR, thickness, centerX, centerY, scalePxPerMm);
                if (points) {
                    sidePolygons.push(`<polygon points="${points}" fill="${colors.disk}" stroke="${colors.stroke}" stroke-width="1.3" />`);
                }
            }

            const innerPx = innerR * scalePxPerMm;
            const outerPx = outerR * scalePxPerMm;
            const crackLocPx = crackLocR * scalePxPerMm;
            const halfThickPx = 0.5 * thickness * scalePxPerMm;
            const crackSizePx = crackSize * scalePxPerMm;

            // Bore highlight
            const boreHighlight = innerR > 0
                ? `<rect x="${(centerX - innerPx).toFixed(2)}" y="16" width="${(2 * innerPx).toFixed(2)}" height="${(h - 32).toFixed(2)}" fill="${colors.bore}" stroke="${colors.boreBorder}" stroke-dasharray="4 3"/>`
                : '';

            // Crack visualization (on right-hand side)
            let crackSvg = '';
            const crackX = centerX + crackLocPx;
            const surfaceTypes = ['edge', 'surface', 'elliptical_surface', 'corner'];
            if (crackLocR >= innerR && crackLocR <= outerR) {
                if (surfaceTypes.includes(crackType)) {
                    // Edge/surface/elliptical/corner crack: notch from top surface downward
                    const notchDepthPx = Math.min(crackSizePx, halfThickPx * 1.8);
                    const notchWidth = Math.max(2, notchDepthPx * 0.15);
                    const yTop = centerY - halfThickPx;
                    crackSvg = `
                        <line x1="${crackX.toFixed(2)}" y1="${yTop.toFixed(2)}" x2="${crackX.toFixed(2)}" y2="${(yTop + notchDepthPx).toFixed(2)}" stroke="${colors.crack}" stroke-width="2.5" stroke-linecap="round"/>
                        <line x1="${(crackX - notchWidth).toFixed(2)}" y1="${yTop.toFixed(2)}" x2="${(crackX + notchWidth).toFixed(2)}" y2="${yTop.toFixed(2)}" stroke="${colors.crack}" stroke-width="2"/>
                    `;
                } else if (crackType === 'through') {
                    // Through crack: line through the full thickness
                    const yTop = centerY - halfThickPx;
                    const yBottom = centerY + halfThickPx;
                    crackSvg = `
                        <line x1="${crackX.toFixed(2)}" y1="${yTop.toFixed(2)}" x2="${crackX.toFixed(2)}" y2="${yBottom.toFixed(2)}" stroke="${colors.crack}" stroke-width="2.5" stroke-linecap="round"/>
                    `;
                } else if (crackType === 'double_edge') {
                    // Double edge: notches from both top and bottom surfaces
                    const notchDepthPx = Math.min(crackSizePx, halfThickPx * 0.8);
                    const yTop = centerY - halfThickPx;
                    const yBottom = centerY + halfThickPx;
                    crackSvg = `
                        <line x1="${crackX.toFixed(2)}" y1="${yTop.toFixed(2)}" x2="${crackX.toFixed(2)}" y2="${(yTop + notchDepthPx).toFixed(2)}" stroke="${colors.crack}" stroke-width="2.5" stroke-linecap="round"/>
                        <line x1="${crackX.toFixed(2)}" y1="${yBottom.toFixed(2)}" x2="${crackX.toFixed(2)}" y2="${(yBottom - notchDepthPx).toFixed(2)}" stroke="${colors.crack}" stroke-width="2.5" stroke-linecap="round"/>
                    `;
                } else {
                    // Embedded/penny: internal ellipse
                    const ry = Math.min(crackSizePx * 0.6, halfThickPx * 0.7);
                    const rx = Math.max(1, ry * 0.3);
                    crackSvg = `
                        <ellipse cx="${crackX.toFixed(2)}" cy="${centerY.toFixed(2)}" rx="${rx.toFixed(2)}" ry="${ry.toFixed(2)}" fill="none" stroke="${colors.crack}" stroke-width="2.5"/>
                    `;
                }

                // Crack location marker line (from axis to crack position)
                crackSvg += `
                    <line x1="${centerX}" y1="${(radialMarkerY + 14).toFixed(2)}" x2="${crackX.toFixed(2)}" y2="${(radialMarkerY + 14).toFixed(2)}" stroke="${colors.crackLoc}" stroke-width="1.2"/>
                    <text x="${(centerX + crackLocPx / 2).toFixed(2)}" y="${(radialMarkerY + 11).toFixed(2)}" font-size="11" fill="${colors.crackLoc}" text-anchor="middle">r<tspan dy="-1" font-size="8">crack</tspan> = ${crackLocR.toFixed(1)} mm</text>
                `;

                // Crack size label
                if (surfaceTypes.includes(crackType) || crackType === 'double_edge') {
                    const yTop = centerY - halfThickPx;
                    const notchDepthPx = Math.min(crackSizePx, halfThickPx * 1.8);
                    crackSvg += `
                        <line x1="${(crackX + 8).toFixed(2)}" y1="${yTop.toFixed(2)}" x2="${(crackX + 8).toFixed(2)}" y2="${(yTop + notchDepthPx).toFixed(2)}" stroke="${colors.crack}" stroke-width="0.8" stroke-dasharray="3 2"/>
                        <text x="${(crackX + 12).toFixed(2)}" y="${(yTop + notchDepthPx / 2 + 3).toFixed(2)}" font-size="10" fill="${colors.crack}">a=${crackSize.toFixed(1)}</text>
                    `;
                }

                // Vertical dashed locator line on right side
                crackSvg += `<line x1="${crackX.toFixed(2)}" y1="${(centerY + halfThickPx + 4).toFixed(2)}" x2="${crackX.toFixed(2)}" y2="${(radialMarkerY + 14).toFixed(2)}" stroke="${colors.crackLoc}" stroke-width="0.8" stroke-dasharray="3 2"/>`;
            }

            // Mirror crack on left side (lighter, just outline)
            if (crackLocR >= innerR && crackLocR <= outerR) {
                const mirrorX = centerX - crackLocPx;
                if (surfaceTypes.includes(crackType)) {
                    const notchDepthPx = Math.min(crackSizePx, halfThickPx * 1.8);
                    const yTop = centerY - halfThickPx;
                    crackSvg += `<line x1="${mirrorX.toFixed(2)}" y1="${yTop.toFixed(2)}" x2="${mirrorX.toFixed(2)}" y2="${(yTop + notchDepthPx).toFixed(2)}" stroke="${colors.crack}" stroke-width="1.5" stroke-linecap="round" opacity="0.4"/>`;
                } else if (crackType === 'through') {
                    const yTop = centerY - halfThickPx;
                    const yBottom = centerY + halfThickPx;
                    crackSvg += `<line x1="${mirrorX.toFixed(2)}" y1="${yTop.toFixed(2)}" x2="${mirrorX.toFixed(2)}" y2="${yBottom.toFixed(2)}" stroke="${colors.crack}" stroke-width="1.5" stroke-linecap="round" opacity="0.4"/>`;
                } else {
                    const ry = Math.min(crackSizePx * 0.6, halfThickPx * 0.7);
                    const rx = Math.max(1, ry * 0.3);
                    crackSvg += `<ellipse cx="${mirrorX.toFixed(2)}" cy="${centerY.toFixed(2)}" rx="${rx.toFixed(2)}" ry="${ry.toFixed(2)}" fill="none" stroke="${colors.crack}" stroke-width="1.5" opacity="0.4"/>`;
                }
            }

            // Geometry label
            const geometryLabel = geom === 'solid_disk' ? 'solid disk' : geom === 'annular_disk' ? 'annular disk' : 'thin ring';

            // Thickness marker
            const thickMarkerX = centerX + outerPx + 14;
            const yTopEdge = centerY - halfThickPx;
            const yBottomEdge = centerY + halfThickPx;

            svg.innerHTML = `
                <rect x="0" y="0" width="${w}" height="${h}" fill="${colors.bg}" />

                <!-- Rotation axis -->
                <line x1="0" y1="${centerY}" x2="${w}" y2="${centerY}" stroke="${colors.axis}" stroke-width="1.1" stroke-dasharray="6 4" />
                <text x="${w - 170}" y="${centerY - 6}" font-size="11" fill="${colors.axisText}">Rotation axis</text>

                <!-- Bore -->
                ${boreHighlight}

                <!-- Disk cross-section -->
                ${sidePolygons.join('')}

                <!-- Crack -->
                ${crackSvg}

                <!-- Outer radius dimension -->
                <line x1="${centerX}" y1="${radialMarkerY}" x2="${(centerX + outerPx).toFixed(2)}" y2="${radialMarkerY}" stroke="${colors.outerR}" stroke-width="1.2" />
                <text x="${(centerX + outerPx / 2).toFixed(2)}" y="${radialMarkerY - 4}" font-size="11" fill="${colors.outerR}" text-anchor="middle">r_o = ${outerR.toFixed(1)} mm</text>

                <!-- Inner radius dimension -->
                ${innerR > 0
                    ? `<line x1="${centerX}" y1="${radialMarkerY - 16}" x2="${(centerX + innerPx).toFixed(2)}" y2="${radialMarkerY - 16}" stroke="${colors.innerR}" stroke-width="1.2" />
                       <text x="${(centerX + innerPx / 2).toFixed(2)}" y="${radialMarkerY - 20}" font-size="11" fill="${colors.innerR}" text-anchor="middle">r_i = ${innerR.toFixed(1)} mm</text>`
                    : ''
                }

                <!-- Thickness dimension -->
                <line x1="${thickMarkerX.toFixed(2)}" y1="${yTopEdge.toFixed(2)}" x2="${thickMarkerX.toFixed(2)}" y2="${yBottomEdge.toFixed(2)}" stroke="${colors.thickness}" stroke-width="1.1" />
                <text x="${(thickMarkerX + 6).toFixed(2)}" y="${(centerY + 4).toFixed(2)}" font-size="11" fill="${colors.thickness}">t = ${thickness.toFixed(1)} mm</text>

                <!-- Label -->
                <text x="14" y="20" font-size="11" fill="${colors.axisText}">Cross-section: ${geometryLabel}</text>
            `;
        }

        // =================================================================
        // CRACK TYPE & ORIENTATION DIAGRAMS
        // =================================================================
        function renderCrackTypeDiagram() {
            const svg = document.getElementById('crack-type-diagram');
            if (!svg) return;
            const selected = document.getElementById('crack_type').value;
            const isDark = document.body.dataset.theme === 'dark' ||
                (document.body.dataset.theme === 'system' && window.matchMedia('(prefers-color-scheme: dark)').matches);

            const bg = isDark ? '#111827' : '#ffffff';
            const matFill = isDark ? '#334155' : '#dde1e9';
            const matStroke = isDark ? '#64748b' : '#9ca3af';
            const crackColor = isDark ? '#f87171' : '#dc2626';
            const dimColor = isDark ? '#60a5fa' : '#2563eb';
            const labelColor = isDark ? '#94a3b8' : '#475569';
            const fadedOpacity = '0.35';

            const types = [
                { key: 'edge',               label: 'Edge' },
                { key: 'through',            label: 'Through' },
                { key: 'surface',            label: 'Surface' },
                { key: 'embedded',           label: 'Embedded' },
                { key: 'elliptical_surface', label: 'Elliptical' },
                { key: 'corner',             label: 'Corner' },
                { key: 'double_edge',        label: 'Dbl Edge' }
            ];

            const cellW = 85, pad = 0;
            const plateW = 48, plateH = 36;
            const row1Y = 6, row2Y = 60;

            let out = `<rect x="0" y="0" width="340" height="110" fill="${bg}"/>`;

            types.forEach((t, i) => {
                const row = i < 4 ? 0 : 1;
                const col = row === 0 ? i : i - 4;
                const cx = pad + col * cellW + cellW / 2;
                const baseY = row === 0 ? row1Y : row2Y;
                const active = t.key === selected;
                const opacity = active ? '1' : fadedOpacity;
                const px = cx - plateW / 2;
                const py = baseY;

                // Plate
                out += `<rect x="${px}" y="${py}" width="${plateW}" height="${plateH}" fill="${matFill}" stroke="${matStroke}" stroke-width="1" opacity="${opacity}" rx="2"/>`;

                // Stress arrows (top)
                for (let ax = px + 8; ax < px + plateW; ax += 14) {
                    out += `<line x1="${ax}" y1="${py - 5}" x2="${ax}" y2="${py}" stroke="${dimColor}" stroke-width="1" opacity="${opacity}" marker-end="url(#arrowDown)"/>`;
                }

                // Crack drawing
                const midY = py + plateH / 2;
                if (t.key === 'edge') {
                    const depth = plateH * 0.45;
                    out += `<line x1="${cx}" y1="${py}" x2="${cx}" y2="${py + depth}" stroke="${crackColor}" stroke-width="2" opacity="${opacity}" stroke-linecap="round"/>`;
                    if (active) {
                        out += `<line x1="${cx + 5}" y1="${py}" x2="${cx + 5}" y2="${py + depth}" stroke="${dimColor}" stroke-width="0.8" stroke-dasharray="2 1.5"/>`;
                        out += `<text x="${cx + 9}" y="${py + depth / 2 + 3}" font-size="8" fill="${dimColor}">a</text>`;
                    }
                } else if (t.key === 'through') {
                    out += `<line x1="${cx}" y1="${py}" x2="${cx}" y2="${py + plateH}" stroke="${crackColor}" stroke-width="2" opacity="${opacity}" stroke-linecap="round"/>`;
                    if (active) {
                        out += `<line x1="${cx + 5}" y1="${py}" x2="${cx + 5}" y2="${py + plateH}" stroke="${dimColor}" stroke-width="0.8" stroke-dasharray="2 1.5"/>`;
                        out += `<text x="${cx + 9}" y="${midY + 3}" font-size="8" fill="${dimColor}">2a</text>`;
                    }
                } else if (t.key === 'surface') {
                    const depth = plateH * 0.4;
                    const halfW = 7;
                    out += `<path d="M ${cx - halfW} ${py} A ${halfW} ${depth} 0 0 1 ${cx + halfW} ${py}" fill="none" stroke="${crackColor}" stroke-width="2" opacity="${opacity}"/>`;
                    if (active) {
                        out += `<line x1="${cx}" y1="${py}" x2="${cx}" y2="${py + depth}" stroke="${dimColor}" stroke-width="0.8" stroke-dasharray="2 1.5"/>`;
                        out += `<text x="${cx + 4}" y="${py + depth / 2 + 3}" font-size="8" fill="${dimColor}">a</text>`;
                    }
                } else if (t.key === 'embedded') {
                    const ry = 6, rx = 10;
                    out += `<ellipse cx="${cx}" cy="${midY}" rx="${rx}" ry="${ry}" fill="none" stroke="${crackColor}" stroke-width="2" opacity="${opacity}"/>`;
                    if (active) {
                        out += `<line x1="${cx - rx}" y1="${midY}" x2="${cx + rx}" y2="${midY}" stroke="${dimColor}" stroke-width="0.8" stroke-dasharray="2 1.5"/>`;
                        out += `<text x="${cx + rx + 3}" y="${midY + 3}" font-size="8" fill="${dimColor}">2a</text>`;
                    }
                } else if (t.key === 'elliptical_surface') {
                    // Semi-ellipse from top surface (wider than semicircular)
                    const depth = plateH * 0.35;
                    const halfW = 12;
                    out += `<path d="M ${cx - halfW} ${py} A ${halfW} ${depth} 0 0 1 ${cx + halfW} ${py}" fill="none" stroke="${crackColor}" stroke-width="2" opacity="${opacity}"/>`;
                    if (active) {
                        out += `<line x1="${cx}" y1="${py}" x2="${cx}" y2="${py + depth}" stroke="${dimColor}" stroke-width="0.8" stroke-dasharray="2 1.5"/>`;
                        out += `<text x="${cx + 4}" y="${py + depth / 2 + 3}" font-size="8" fill="${dimColor}">a</text>`;
                        out += `<line x1="${cx - halfW}" y1="${py + 2}" x2="${cx + halfW}" y2="${py + 2}" stroke="${dimColor}" stroke-width="0.8" stroke-dasharray="2 1.5"/>`;
                        out += `<text x="${cx + halfW + 3}" y="${py + 5}" font-size="7" fill="${dimColor}">2c</text>`;
                    }
                } else if (t.key === 'corner') {
                    // Quarter-ellipse in corner
                    const depth = plateH * 0.4;
                    const cornerW = 10;
                    out += `<path d="M ${px} ${py} L ${px} ${py + depth} A ${cornerW} ${depth} 0 0 0 ${px + cornerW} ${py}" fill="none" stroke="${crackColor}" stroke-width="2" opacity="${opacity}"/>`;
                    if (active) {
                        out += `<line x1="${px + 2}" y1="${py}" x2="${px + 2}" y2="${py + depth}" stroke="${dimColor}" stroke-width="0.8" stroke-dasharray="2 1.5"/>`;
                        out += `<text x="${px + 6}" y="${py + depth / 2 + 3}" font-size="8" fill="${dimColor}">a</text>`;
                    }
                } else if (t.key === 'double_edge') {
                    // Two notches from both sides
                    const depth = plateH * 0.35;
                    out += `<line x1="${px}" y1="${midY}" x2="${px + depth}" y2="${midY}" stroke="${crackColor}" stroke-width="2" opacity="${opacity}" stroke-linecap="round"/>`;
                    out += `<line x1="${px + plateW}" y1="${midY}" x2="${px + plateW - depth}" y2="${midY}" stroke="${crackColor}" stroke-width="2" opacity="${opacity}" stroke-linecap="round"/>`;
                    if (active) {
                        out += `<line x1="${px}" y1="${midY + 5}" x2="${px + depth}" y2="${midY + 5}" stroke="${dimColor}" stroke-width="0.8" stroke-dasharray="2 1.5"/>`;
                        out += `<text x="${px + depth / 2}" y="${midY + 14}" font-size="8" fill="${dimColor}" text-anchor="middle">a</text>`;
                    }
                }

                // Label
                const labelWeight = active ? '600' : '400';
                out += `<text x="${cx}" y="${py + plateH + 12}" font-size="8" fill="${active ? crackColor : labelColor}" text-anchor="middle" font-weight="${labelWeight}">${t.label}</text>`;
            });

            // Arrow marker definition
            out = `<defs><marker id="arrowDown" markerWidth="6" markerHeight="6" refX="3" refY="5" orient="auto"><path d="M1,1 L3,5 L5,1" fill="none" stroke="${dimColor}" stroke-width="1"/></marker></defs>` + out;

            svg.innerHTML = out;
        }

        function renderCrackOrientationDiagram() {
            const svg = document.getElementById('crack-orientation-diagram');
            if (!svg) return;
            const selected = document.getElementById('crack_orientation').value;
            const isDark = document.body.dataset.theme === 'dark' ||
                (document.body.dataset.theme === 'system' && window.matchMedia('(prefers-color-scheme: dark)').matches);

            const bg = isDark ? '#111827' : '#ffffff';
            const diskFill = isDark ? '#334155' : '#dde1e9';
            const diskStroke = isDark ? '#64748b' : '#9ca3af';
            const crackColor = isDark ? '#f87171' : '#dc2626';
            const hoopColor = isDark ? '#34d399' : '#0f766e';
            const radialColor = isDark ? '#fbbf24' : '#b45309';
            const labelColor = isDark ? '#94a3b8' : '#475569';
            const axisColor = isDark ? '#475569' : '#cbd5e1';
            const fadedOpacity = '0.3';

            const cellW = 170;
            const cx1 = cellW / 2, cx2 = cellW + cellW / 2;
            const cy = 50;
            const ri = 18, ro = 40;

            let out = `<rect x="0" y="0" width="340" height="110" fill="${bg}"/>`;

            // Defs for arrowheads
            out += `<defs>
                <marker id="hoopArr" markerWidth="6" markerHeight="6" refX="5" refY="3" orient="auto"><path d="M0,0 L6,3 L0,6" fill="${hoopColor}"/></marker>
                <marker id="radArr" markerWidth="6" markerHeight="6" refX="5" refY="3" orient="auto"><path d="M0,0 L6,3 L0,6" fill="${radialColor}"/></marker>
                <marker id="openArr" markerWidth="5" markerHeight="5" refX="4" refY="2.5" orient="auto"><path d="M0,0 L5,2.5 L0,5" fill="${crackColor}"/></marker>
            </defs>`;

            const orientations = [
                { key: 'circumferential', label: 'Circumferential', cx: cx1 },
                { key: 'radial',          label: 'Radial',          cx: cx2 }
            ];

            orientations.forEach(o => {
                const active = o.key === selected;
                const opacity = active ? '1' : fadedOpacity;
                const x = o.cx;

                // Disk ring (top-down view)
                out += `<circle cx="${x}" cy="${cy}" r="${ro}" fill="${diskFill}" stroke="${diskStroke}" stroke-width="1" opacity="${opacity}"/>`;
                out += `<circle cx="${x}" cy="${cy}" r="${ri}" fill="${bg}" stroke="${diskStroke}" stroke-width="1" opacity="${opacity}"/>`;

                // Cross-hair axes
                out += `<line x1="${x - ro - 6}" y1="${cy}" x2="${x + ro + 6}" y2="${cy}" stroke="${axisColor}" stroke-width="0.6" opacity="${opacity}"/>`;
                out += `<line x1="${x}" y1="${cy - ro - 6}" x2="${x}" y2="${cy + ro + 6}" stroke="${axisColor}" stroke-width="0.6" opacity="${opacity}"/>`;

                // Radial stress arrows (pointing outward at 45 and 225)
                const rMid = (ri + ro) / 2;
                const ang45 = Math.PI / 4;
                for (const angOff of [ang45, ang45 + Math.PI]) {
                    const cos = Math.cos(angOff), sin = Math.sin(angOff);
                    const x1a = x + (rMid - 6) * cos, y1a = cy - (rMid - 6) * sin;
                    const x2a = x + (rMid + 6) * cos, y2a = cy - (rMid + 6) * sin;
                    out += `<line x1="${x1a.toFixed(1)}" y1="${y1a.toFixed(1)}" x2="${x2a.toFixed(1)}" y2="${y2a.toFixed(1)}" stroke="${radialColor}" stroke-width="1.3" marker-end="url(#radArr)" opacity="${opacity}"/>`;
                }

                // Hoop stress arrows (tangential arcs at ~135 and ~315)
                for (const angCenter of [Math.PI * 3 / 4, Math.PI * 7 / 4]) {
                    const arcR = rMid;
                    const span = 0.35;
                    const a1 = angCenter - span, a2 = angCenter + span;
                    const sx = x + arcR * Math.cos(a1), sy = cy - arcR * Math.sin(a1);
                    const ex = x + arcR * Math.cos(a2), ey = cy - arcR * Math.sin(a2);
                    out += `<path d="M ${sx.toFixed(1)} ${sy.toFixed(1)} A ${arcR} ${arcR} 0 0 0 ${ex.toFixed(1)} ${ey.toFixed(1)}" fill="none" stroke="${hoopColor}" stroke-width="1.3" marker-end="url(#hoopArr)" opacity="${opacity}"/>`;
                }

                // Crack line at ~0 (3 o'clock position in the ring)
                const crackR = rMid;
                if (o.key === 'circumferential') {
                    // Crack runs tangentially (arc at 0)
                    const crackSpan = 0.3;
                    const ca1 = -crackSpan, ca2 = crackSpan;
                    const csx = x + crackR * Math.cos(ca1), csy = cy - crackR * Math.sin(ca1);
                    const cex = x + crackR * Math.cos(ca2), cey = cy - crackR * Math.sin(ca2);
                    out += `<path d="M ${csx.toFixed(1)} ${csy.toFixed(1)} A ${crackR} ${crackR} 0 0 0 ${cex.toFixed(1)} ${cey.toFixed(1)}" fill="none" stroke="${crackColor}" stroke-width="2.5" opacity="${opacity}" stroke-linecap="round"/>`;
                    // Opening arrows (radial, pushing apart)
                    if (active) {
                        const mx = x + crackR, my = cy;
                        out += `<line x1="${mx + 2}" y1="${my}" x2="${mx + 9}" y2="${my}" stroke="${crackColor}" stroke-width="1" marker-end="url(#openArr)"/>`;
                        out += `<line x1="${mx - 2}" y1="${my}" x2="${mx - 9}" y2="${my}" stroke="${crackColor}" stroke-width="1" marker-end="url(#openArr)" transform="rotate(180 ${mx - 3.5} ${my})"/>`;
                    }
                } else {
                    // Crack runs radially (straight line at 0)
                    const crackLen = 12;
                    const csx = x + crackR - crackLen / 2, cex = x + crackR + crackLen / 2;
                    out += `<line x1="${csx.toFixed(1)}" y1="${cy}" x2="${cex.toFixed(1)}" y2="${cy}" stroke="${crackColor}" stroke-width="2.5" opacity="${opacity}" stroke-linecap="round"/>`;
                    // Opening arrows (tangential, pushing apart)
                    if (active) {
                        const mx = x + crackR;
                        out += `<line x1="${mx}" y1="${cy - 2}" x2="${mx}" y2="${cy - 9}" stroke="${crackColor}" stroke-width="1" marker-end="url(#openArr)"/>`;
                        out += `<line x1="${mx}" y1="${cy + 2}" x2="${mx}" y2="${cy + 9}" stroke="${crackColor}" stroke-width="1" marker-end="url(#openArr)"/>`;
                    }
                }

                // Label
                const labelWeight = active ? '600' : '400';
                out += `<text x="${x}" y="${cy + ro + 16}" font-size="9" fill="${active ? crackColor : labelColor}" text-anchor="middle" font-weight="${labelWeight}">${o.label}</text>`;

                // Stress legend (only for active)
                if (active) {
                    out += `<line x1="${x - 30}" y1="${cy + ro + 22}" x2="${x - 20}" y2="${cy + ro + 22}" stroke="${hoopColor}" stroke-width="1.5"/>`;
                    out += `<text x="${x - 17}" y="${cy + ro + 25}" font-size="7" fill="${hoopColor}">_</text>`;
                    out += `<line x1="${x + 8}" y1="${cy + ro + 22}" x2="${x + 18}" y2="${cy + ro + 22}" stroke="${radialColor}" stroke-width="1.5"/>`;
                    out += `<text x="${x + 21}" y="${cy + ro + 25}" font-size="7" fill="${radialColor}">_r</text>`;
                }
            });

            svg.innerHTML = out;
        }

        // =================================================================
        // TAB INTERFACE
        // =================================================================
        function openTab(event, tabName) {
            document.querySelectorAll('.tab-content').forEach(tab => tab.style.display = 'none');
            document.querySelectorAll('.tab-link').forEach(link => link.classList.remove('active'));
            document.getElementById(tabName).style.display = 'block';
            event.currentTarget.classList.add('active');
            typesetMath();
            if (tabName === 'visualization') {
                renderCrossSectionPreview();
                setTimeout(() => {
                    const plotEl = document.getElementById('ki-plot');
                    if (plotEl && plotEl.data) Plotly.Plots.resize(plotEl);
                }, 100);
            } else if (tabName === 'crack-growth') {
                setTimeout(() => {
                    const plotEl = document.getElementById('growth-plot');
                    if (plotEl && plotEl.data) Plotly.Plots.resize(plotEl);
                }, 100);
            } else if (tabName === 'sensitivity') {
                // Show controls once baseline exists
                if (lastResults) {
                    document.getElementById('sensitivity-placeholder').style.display = 'none';
                    document.getElementById('sensitivity-controls').style.display = 'block';
                    onSweepParamChange();
                }
                setTimeout(() => {
                    ['sensitivity-sf-plot', 'sensitivity-nf-plot', 'sensitivity-life-plot'].forEach(id => {
                        const el = document.getElementById(id);
                        if (el && el.data) Plotly.Plots.resize(el);
                    });
                }, 100);
            }
        }

        function typesetMath() { if (window.MathJax && window.MathJax.typesetPromise) MathJax.typesetPromise(); }

        // =================================================================
        // UI HELPERS
        // =================================================================
        function onGeometryChange() {
            const geom = document.getElementById('geometry_type').value;
            const innerGroup = document.getElementById('inner-radius-group');
            innerGroup.style.display = geom === 'solid_disk' ? 'none' : 'block';
            renderCrossSectionPreview();
        }

        function onCrackTypeChange() {
            const ct = document.getElementById('crack_type').value;
            const arGroup = document.getElementById('aspect-ratio-group');
            arGroup.style.display = (ct === 'elliptical_surface' || ct === 'corner') ? 'block' : 'none';
            renderCrossSectionPreview();
            renderCrackTypeDiagram();
        }

        function onMaterialChange() {
            const preset = document.getElementById('material_preset').value;
            const mat = FRACTURE_MATERIALS[preset];
            if (mat) {
                document.getElementById('fracture_toughness').value = mat.K_IC;
                document.getElementById('paris_C').value = mat.paris_C;
                document.getElementById('paris_m').value = mat.paris_m;
                document.getElementById('density_kg_m3').value = mat.density;
                document.getElementById('tensile_strength_mpa').value = mat.sigma_uts;
            }
        }

        function toggleGaugeExplainer(mode) {
            const explainer = document.getElementById('explainer-' + mode);
            if (openExplainer && openExplainer !== mode) {
                document.getElementById('explainer-' + openExplainer).classList.remove('visible');
            }
            if (explainer.classList.contains('visible')) {
                explainer.classList.remove('visible');
                openExplainer = null;
            } else {
                explainer.classList.add('visible');
                openExplainer = mode;
                typesetMath();
            }
        }

        function toggleExpertMode() {
            const toggle = document.getElementById('expert-mode-toggle');
            const status = document.getElementById('expert-mode-status');
            document.body.classList.toggle('expert-mode', toggle.checked);
            status.textContent = toggle.checked ? 'On' : 'Off';
            settings.expertMode = toggle.checked;
            saveSettings();
        }

        function applyExpertMode() {
            const toggle = document.getElementById('expert-mode-toggle');
            const status = document.getElementById('expert-mode-status');
            if (settings.expertMode) {
                toggle.checked = true; status.textContent = 'On';
                document.body.classList.add('expert-mode');
            } else {
                toggle.checked = false; status.textContent = 'Off';
                document.body.classList.remove('expert-mode');
            }
        }

        function toggleDerivation(key) {
            const panel = document.getElementById('deriv-' + key);
            const item = document.querySelector(`.result-item[data-key="${key}"]`);
            if (openDerivation && openDerivation !== key) {
                document.getElementById('deriv-' + openDerivation).classList.remove('visible');
                document.querySelector(`.result-item[data-key="${openDerivation}"]`)?.classList.remove('expanded');
            }
            if (panel.classList.contains('visible')) {
                panel.classList.remove('visible');
                item?.classList.remove('expanded');
                openDerivation = null;
            } else {
                panel.classList.add('visible');
                item?.classList.add('expanded');
                openDerivation = key;
                typesetMath();
            }
        }

        function buildMaterialTable() {
            const container = document.getElementById('material-table-container');
            if (!container) return;
            let html = '<table class="mat-table"><thead><tr>';
            html += '<th>Material</th><th>K<sub>IC</sub> (MPa&radic;m)</th><th>Paris C</th>';
            html += '<th>Paris m</th><th>&rho; (kg/m&sup3;)</th><th>&sigma;<sub>uts</sub> (MPa)</th></tr></thead><tbody>';
            for (const [key, mat] of Object.entries(FRACTURE_MATERIALS)) {
                html += `<tr><td>${mat.display_name}</td><td>${mat.K_IC}</td><td>${mat.paris_C}</td>`;
                html += `<td>${mat.paris_m}</td><td>${mat.density}</td><td>${mat.sigma_uts}</td></tr>`;
            }
            html += '</tbody></table>';
            container.innerHTML = html;
        }

        function getGaugeClass(sf, threshold = 1.5) {
            if (sf >= threshold) return 'success';
            if (sf >= 1.0) return 'warning';
            return 'danger';
        }

        function getGaugeWidth(sf, maxSF = 4.0) {
            return Math.min(100, (sf / maxSF) * 100);
        }

        // =================================================================
        // PYODIDE INITIALIZATION
        // =================================================================
        async function main() {
            const loadingText = document.getElementById('loading-text');
            loadSettings();
            applySettings();
            bindSettingsControls();

            try {
                loadingText.textContent = 'Loading Pyodide...';
                let pyodide = await loadPyodide();

                loadingText.textContent = 'Loading Python modules...';
                await pyodide.loadPackage('micropip');

                await pyodide.runPythonAsync(`
                    import micropip
                    from pyodide.http import pyfetch

                    _cb = str(int(__import__('time').time()))
                    response_utils = await pyfetch('../../pycalcs/utils.py?v=' + _cb)
                    with open('utils.py', 'w') as f:
                        f.write(await response_utils.string())

                    response_tool = await pyfetch('../../pycalcs/${TOOL_MODULE_NAME}.py?v=' + _cb)
                    with open('${TOOL_MODULE_NAME}.py', 'w') as f:
                        f.write(await response_tool.string())

                    import utils
                    import ${TOOL_MODULE_NAME}
                `);

                pyUtils = pyodide.globals.get('utils');
                pyToolModule = pyodide.globals.get(TOOL_MODULE_NAME);

                loadingText.textContent = 'Parsing documentation...';
                const docMap = pyUtils.get_documentation(TOOL_MODULE_NAME, TOOL_FUNCTION_NAME).toJs();
                if (docMap.has('error')) {
                    console.error('Docstring Error:', docMap.get('error'));
                } else {
                    toolDocumentation = Object.fromEntries(docMap);
                    if (toolDocumentation.parameters) toolDocumentation.parameters = Object.fromEntries(toolDocumentation.parameters);
                    if (toolDocumentation.returns) toolDocumentation.returns = Object.fromEntries(toolDocumentation.returns);
                }

                document.getElementById('calc-form').addEventListener('submit', handleCalculate);
                document.getElementById('export-csv-btn').addEventListener('click', exportCSV);
                document.getElementById('loading-overlay').classList.add('hidden');
                document.getElementById('calculate-btn').textContent = 'Calculate';
                document.getElementById('calculate-btn').disabled = false;

                // Live cross-section preview
                ['inner_radius_mm', 'outer_radius_mm', 'thickness_mm', 'crack_location_radius_mm', 'initial_crack_size_mm'].forEach(id => {
                    const el = document.getElementById(id);
                    if (el) { el.addEventListener('input', renderCrossSectionPreview); el.addEventListener('change', renderCrossSectionPreview); }
                });
                document.getElementById('crack_type').addEventListener('change', onCrackTypeChange);
                document.getElementById('crack_orientation').addEventListener('change', renderCrackOrientationDiagram);
                renderCrossSectionPreview();
                renderCrackTypeDiagram();
                renderCrackOrientationDiagram();
                buildMaterialTable();

                // Sensitivity sweep controls
                document.getElementById('sweep-param').addEventListener('change', onSweepParamChange);
                document.getElementById('run-sweep-btn').addEventListener('click', runSensitivity);

            } catch (error) {
                loadingText.textContent = 'Error loading: ' + error.message;
                console.error(error);
            }
        }
        main();

        // =================================================================
        // CALCULATION HANDLER
        // =================================================================
        async function handleCalculate(event) {
            event.preventDefault();
            const btn = document.getElementById('calculate-btn');
            btn.textContent = 'Calculating...';
            btn.disabled = true;

            try {
                const geom = document.getElementById('geometry_type').value;
                const inner_r = parseFloat(document.getElementById('inner_radius_mm').value) || 0;
                const outer_r = parseFloat(document.getElementById('outer_radius_mm').value);
                const speed = parseFloat(document.getElementById('speed_rpm').value);
                const crack_loc = parseFloat(document.getElementById('crack_location_radius_mm').value);
                const crack_size = parseFloat(document.getElementById('initial_crack_size_mm').value);
                const crack_t = document.getElementById('crack_type').value;
                const crack_orient = document.getElementById('crack_orientation').value;
                const mat_preset = document.getElementById('material_preset').value;
                const k_ic = parseFloat(document.getElementById('fracture_toughness').value);
                const pC = parseFloat(document.getElementById('paris_C').value);
                const pm = parseFloat(document.getElementById('paris_m').value);
                const density = parseFloat(document.getElementById('density_kg_m3').value);
                const poisson = parseFloat(document.getElementById('poisson_ratio').value);
                const uts = parseFloat(document.getElementById('tensile_strength_mpa').value);
                const R = parseFloat(document.getElementById('stress_ratio_R').value);
                const design_life = parseFloat(document.getElementById('design_life_cycles').value);
                const req_sf = parseFloat(document.getElementById('required_fracture_sf').value);
                const thickness = parseFloat(document.getElementById('thickness_mm').value);

                const crack_ar = parseFloat(document.getElementById('crack_aspect_ratio').value) || 1.0;

                const resultProxy = pyToolModule.analyze_fracture_and_crack_growth(
                    geom, inner_r, outer_r, speed, crack_loc, crack_size,
                    crack_t, crack_orient, mat_preset,
                    k_ic, pC, pm, density, poisson, uts,
                    R, design_life, req_sf, thickness, crack_ar
                );

                lastResults = resultProxy.toJs({ dict_converter: Object.fromEntries });
                resultProxy.destroy();

                // Convert nested dicts
                ['crack_growth_curve', 'K_vs_a_curve'].forEach(key => {
                    if (lastResults[key]) {
                        lastResults[key] = Object.fromEntries(
                            Object.entries(lastResults[key]).map(([k, v]) =>
                                [k, Array.isArray(v) ? v : (v instanceof Map ? Array.from(v.values()) : v)]
                            )
                        );
                    }
                });
                if (lastResults.recommendations && lastResults.recommendations instanceof Map) {
                    lastResults.recommendations = Array.from(lastResults.recommendations.values());
                }

                displayResults(lastResults, req_sf);

            } catch (error) {
                console.error('Calculation error:', error);
                document.getElementById('results-placeholder').textContent = 'Error: ' + error.message;
                document.getElementById('results-placeholder').style.color = 'var(--danger-color)';
            }

            btn.textContent = 'Calculate';
            btn.disabled = false;
        }

        // =================================================================
        // DISPLAY RESULTS
        // =================================================================
        function displayResults(r, reqSF) {
            // Fracture tab
            document.getElementById('results-placeholder').style.display = 'none';
            document.getElementById('results-grid').style.display = 'grid';
            document.getElementById('safety-section').style.display = 'block';
            document.getElementById('status-banner').style.display = 'flex';

            document.getElementById('val-K_I').innerHTML = formatNumber(r.K_I_mpa_sqrt_m) + '<span class="unit">MPa&radic;m</span>';
            document.getElementById('val-fracture_sf').innerHTML = formatNumber(r.fracture_safety_factor, 2);
            document.getElementById('val-a_cr').innerHTML = formatNumber(r.critical_crack_size_mm) + '<span class="unit">mm</span>';
            document.getElementById('val-hoop').innerHTML = formatNumber(r.applied_hoop_stress_mpa) + '<span class="unit">MPa</span>';

            // Substituted equations
            if (r.subst_K_I_mpa_sqrt_m) document.getElementById('subst-K_I').innerHTML = '$$' + r.subst_K_I_mpa_sqrt_m + '$$';
            if (r.subst_fracture_safety_factor) document.getElementById('subst-fracture_sf').innerHTML = '$$' + r.subst_fracture_safety_factor + '$$';
            if (r.subst_critical_crack_size_mm) document.getElementById('subst-a_cr').innerHTML = '$$' + r.subst_critical_crack_size_mm + '$$';
            if (r.subst_applied_hoop_stress) document.getElementById('subst-hoop_stress').innerHTML = '$$' + r.subst_applied_hoop_stress + '$$';

            // Show derivations setting
            if (settings.showDerivations && !openDerivation) toggleDerivation('K_I');
            if (settings.showGauges && !openExplainer) toggleGaugeExplainer('fracture');

            // Fracture safety gauge
            const sfClass = getGaugeClass(r.fracture_safety_factor, reqSF);
            document.getElementById('gauge-fracture-bar').className = 'gauge-bar ' + sfClass;
            document.getElementById('gauge-fracture-bar').style.width = getGaugeWidth(r.fracture_safety_factor) + '%';
            document.getElementById('gauge-fracture-value').className = 'gauge-value ' + sfClass;
            document.getElementById('gauge-fracture-value').textContent = 'SF = ' + r.fracture_safety_factor.toFixed(2);
            document.getElementById('gauge-fracture-threshold').style.left = getGaugeWidth(reqSF) + '%';

            // Fracture explainer
            document.getElementById('explainer-fracture-kic').textContent = 'K_IC: ' + r.K_IC_mpa_sqrt_m.toFixed(1) + ' MPa\u221Am';
            document.getElementById('explainer-fracture-ki').textContent = 'K_I: ' + r.K_I_mpa_sqrt_m.toFixed(3) + ' MPa\u221Am';
            document.getElementById('explainer-fracture-sf').textContent = 'SF: ' + r.fracture_safety_factor.toFixed(2);
            const guidanceF = document.getElementById('explainer-fracture-guidance');
            if (r.fracture_safety_factor >= reqSF) {
                guidanceF.className = 'explainer-guidance good';
                guidanceF.textContent = 'Fracture safety factor meets the requirement of ' + reqSF.toFixed(1) + '. Crack is stable at this size.';
            } else if (r.fracture_safety_factor >= 1.0) {
                guidanceF.className = 'explainer-guidance marginal';
                guidanceF.textContent = 'Below the target of ' + reqSF.toFixed(1) + ' but above 1.0. Crack is stable but margin is low.';
            } else {
                guidanceF.className = 'explainer-guidance bad';
                guidanceF.textContent = 'K_I exceeds K_IC. Immediate brittle fracture predicted at this crack size and speed.';
            }

            // Critical crack note (Fix #4)
            const acrEl = document.getElementById('val-a_cr');
            if (r.critical_crack_reached === false) {
                acrEl.innerHTML += '<span class="unit" style="color:var(--warning-color);"> (K never reaches K_IC)</span>';
            }

            // Life fraction gauge
            const lifeFrac = r.life_fraction_used;
            const lifeClass = lifeFrac <= 0.5 ? 'success' : lifeFrac <= 1.0 ? 'warning' : 'danger';
            document.getElementById('gauge-life-bar').className = 'gauge-bar ' + lifeClass;
            document.getElementById('gauge-life-bar').style.width = Math.min(100, lifeFrac * 100) + '%';
            document.getElementById('gauge-life-value').className = 'gauge-value ' + lifeClass;
            document.getElementById('gauge-life-value').textContent = (lifeFrac * 100).toFixed(0) + '%';
            document.getElementById('gauge-life-threshold').style.left = '100%';

            const designLife = parseFloat(document.getElementById('design_life_cycles').value);
            document.getElementById('explainer-life-design').textContent = 'Design: ' + formatCycles(designLife) + ' cycles';
            document.getElementById('explainer-life-predicted').textContent = 'N_f: ' + formatCycles(r.cycles_to_failure) + ' cycles';
            document.getElementById('explainer-life-fraction').textContent = 'Fraction: ' + (lifeFrac * 100).toFixed(1) + '%';

            // Populate life fraction derivation steps (Fracture tab)
            if (r.subst_nf_step_delta_sigma) {
                document.getElementById('explainer-life-delta-sigma').innerHTML = '$$' + r.subst_nf_step_delta_sigma + '$$';
                document.getElementById('explainer-life-delta-K').innerHTML = '$$' + r.subst_nf_step_delta_K + '$$';
                document.getElementById('explainer-life-dadN').innerHTML = '$$' + r.subst_nf_step_dadN + '$$';
                document.getElementById('explainer-life-integral').innerHTML = '$$' + r.subst_nf_step_integral + '$$';
                if (r.subst_life_fraction_used) {
                    document.getElementById('explainer-life-frac-eq').innerHTML = '$$' + r.subst_life_fraction_used + '$$';
                }
                document.getElementById('explainer-life-steps').style.display = 'block';
            }
            const guidanceL = document.getElementById('explainer-life-guidance');
            if (lifeFrac <= 0.5) {
                guidanceL.className = 'explainer-guidance good';
                guidanceL.textContent = 'Predicted crack growth life well exceeds the design life target.';
            } else if (lifeFrac <= 1.0) {
                guidanceL.className = 'explainer-guidance marginal';
                guidanceL.textContent = 'Predicted life is close to the design life. Increase inspection frequency.';
            } else {
                guidanceL.className = 'explainer-guidance bad';
                guidanceL.textContent = 'Design life exceeds predicted crack growth life. Component will not meet service target.';
            }

            // Status banner
            const banner = document.getElementById('status-banner');
            banner.className = 'status-banner ' + r.status;
            const statusTitles = { acceptable: 'Fracture Assessment: Acceptable', marginal: 'Fracture Assessment: Marginal', unacceptable: 'Fracture Assessment: Unacceptable' };
            const statusIcons = { acceptable: '&#10003;', marginal: '&#9888;', unacceptable: '&#10007;' };
            const statusMessages = { acceptable: 'Fracture safety factor meets requirements.', marginal: 'Safety factor is below the target but above 1.0.', unacceptable: 'Crack exceeds critical threshold or safety factor is below 1.0.' };
            document.getElementById('status-icon').innerHTML = statusIcons[r.status];
            document.getElementById('status-title').textContent = statusTitles[r.status];
            document.getElementById('status-message').textContent = statusMessages[r.status];

            const recList = document.getElementById('recommendations-list');
            recList.innerHTML = '';
            if (r.recommendations) {
                const recs = Array.isArray(r.recommendations) ? r.recommendations : Array.from(r.recommendations.values());
                recs.forEach(rec => { const li = document.createElement('li'); li.textContent = rec; recList.appendChild(li); });
            }

            document.getElementById('export-section').style.display = 'block';

            // Enable sensitivity tab controls
            document.getElementById('sensitivity-placeholder').style.display = 'none';
            document.getElementById('sensitivity-controls').style.display = 'block';

            // Crack growth tab
            document.getElementById('growth-placeholder').style.display = 'none';
            document.getElementById('growth-grid').style.display = 'grid';
            document.getElementById('growth-chart-container').style.display = 'block';

            const noCritical = r.critical_crack_reached === false;
            if (noCritical) {
                document.getElementById('val-cycles').innerHTML = '&infin; <span class="unit" style="color:var(--warning-color);">(K never reaches K_IC)</span>';
                document.getElementById('val-inspection').innerHTML = 'N/A';
                document.getElementById('val-life-fraction').innerHTML = '0 <span class="unit">%</span>';
            } else {
                document.getElementById('val-cycles').innerHTML = formatCycles(r.cycles_to_failure) + '<span class="unit">cycles</span>';
                document.getElementById('val-inspection').innerHTML = formatCycles(r.inspection_interval_cycles) + '<span class="unit">cycles</span>';
                document.getElementById('val-life-fraction').innerHTML = (lifeFrac * 100).toFixed(1) + '<span class="unit">%</span>';
            }
            document.getElementById('val-growth-rate').innerHTML = r.crack_growth_rate_mm_per_cycle.toExponential(2);
            // Populate N_f derivation steps (Crack Growth tab)
            if (r.subst_nf_step_delta_sigma) document.getElementById('subst-nf-delta-sigma').innerHTML = '$$' + r.subst_nf_step_delta_sigma + '$$';
            if (r.subst_nf_step_delta_K) document.getElementById('subst-nf-delta-K').innerHTML = '$$' + r.subst_nf_step_delta_K + '$$';
            if (r.subst_nf_step_dadN) document.getElementById('subst-nf-dadN').innerHTML = '$$' + r.subst_nf_step_dadN + '$$';
            if (r.subst_nf_step_integral) document.getElementById('subst-nf-integral').innerHTML = '$$' + r.subst_nf_step_integral + '$$';
            if (r.subst_life_fraction_used) document.getElementById('subst-life_fraction').innerHTML = '$$' + r.subst_life_fraction_used + '$$';

            // Plot charts
            plotCrackGrowth(r.crack_growth_curve, r.inspection_interval_cycles);
            plotKvsA(r.K_vs_a_curve);

            typesetMath();
        }

        // =================================================================
        // CSV EXPORT
        // =================================================================
        function downloadFile(content, filename, mimeType) {
            const blob = new Blob([content], { type: mimeType });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function exportCSV() {
            if (!lastResults) return;
            const r = lastResults;
            const rows = [];

            // Section 1: Inputs
            rows.push('Parameter,Value,Unit');
            rows.push('Geometry,' + document.getElementById('geometry_type').value + ',');
            rows.push('Inner Radius,' + document.getElementById('inner_radius_mm').value + ',mm');
            rows.push('Outer Radius,' + document.getElementById('outer_radius_mm').value + ',mm');
            rows.push('Thickness,' + document.getElementById('thickness_mm').value + ',mm');
            rows.push('Speed,' + document.getElementById('speed_rpm').value + ',RPM');
            rows.push('Crack Location Radius,' + document.getElementById('crack_location_radius_mm').value + ',mm');
            rows.push('Initial Crack Size,' + document.getElementById('initial_crack_size_mm').value + ',mm');
            rows.push('Crack Type,' + document.getElementById('crack_type').value + ',');
            rows.push('Crack Orientation,' + document.getElementById('crack_orientation').value + ',');
            rows.push('Material,' + document.getElementById('material_preset').value + ',');
            rows.push('Fracture Toughness (K_IC),' + document.getElementById('fracture_toughness').value + ',MPa*sqrt(m)');
            rows.push('Paris C,' + document.getElementById('paris_C').value + ',');
            rows.push('Paris m,' + document.getElementById('paris_m').value + ',');
            rows.push('Density,' + document.getElementById('density_kg_m3').value + ',kg/m^3');
            rows.push('Poisson Ratio,' + document.getElementById('poisson_ratio').value + ',');
            rows.push('Tensile Strength,' + document.getElementById('tensile_strength_mpa').value + ',MPa');
            rows.push('Stress Ratio (R),' + document.getElementById('stress_ratio_R').value + ',');
            rows.push('Design Life,' + document.getElementById('design_life_cycles').value + ',cycles');
            rows.push('Required SF,' + document.getElementById('required_fracture_sf').value + ',');

            // Blank line separator
            rows.push('');

            // Section 2: Results
            rows.push('Result,Value,Unit');
            rows.push('K_I,' + r.K_I_mpa_sqrt_m + ',MPa*sqrt(m)');
            rows.push('K_IC,' + r.K_IC_mpa_sqrt_m + ',MPa*sqrt(m)');
            rows.push('Fracture Safety Factor,' + r.fracture_safety_factor + ',');
            rows.push('Critical Crack Size,' + r.critical_crack_size_mm + ',mm');
            rows.push('Cycles to Failure,' + r.cycles_to_failure + ',cycles');
            rows.push('Inspection Interval,' + r.inspection_interval_cycles + ',cycles');
            rows.push('Crack Growth Rate,' + r.crack_growth_rate_mm_per_cycle + ',mm/cycle');
            rows.push('Applied Hoop Stress,' + r.applied_hoop_stress_mpa + ',MPa');
            rows.push('Life Fraction Used,' + r.life_fraction_used + ',');
            rows.push('Status,' + r.status + ',');

            // Section 3: Crack Growth Curve
            if (r.crack_growth_curve && r.crack_growth_curve.cycles && r.crack_growth_curve.crack_size_mm) {
                rows.push('');
                rows.push('Cycles,Crack Size (mm)');
                const N = r.crack_growth_curve.cycles;
                const a = r.crack_growth_curve.crack_size_mm;
                for (let i = 0; i < N.length; i++) {
                    rows.push(N[i] + ',' + a[i]);
                }
            }

            downloadFile(rows.join('\n'), 'composite-fracture-results.csv', 'text/csv');
        }

        // =================================================================
        // PLOTTING
        // =================================================================
        function getChartTheme() {
            const cs = getComputedStyle(document.body);
            return {
                bgColor: cs.getPropertyValue('--bg-card').trim() || '#ffffff',
                textColor: cs.getPropertyValue('--text-color').trim() || '#111827',
                gridColor: cs.getPropertyValue('--border-color').trim() || '#e5e7eb',
                successColor: cs.getPropertyValue('--success-color').trim() || '#0f766e',
                accentColor: cs.getPropertyValue('--accent-color').trim() || '#111827',
                dangerColor: cs.getPropertyValue('--danger-color').trim() || '#b91c1c',
                warningColor: cs.getPropertyValue('--warning-color').trim() || '#b45309',
            };
        }

        function plotCrackGrowth(data, inspectionInterval) {
            if (!data || !data.cycles || data.cycles.length < 2) return;
            const theme = getChartTheme();

            const traces = [{
                x: data.cycles,
                y: data.crack_size_mm,
                name: 'Crack Size',
                type: 'scatter',
                mode: 'lines',
                line: { color: theme.accentColor, width: 2 }
            }];

            // Add inspection interval line
            if (Number.isFinite(inspectionInterval) && inspectionInterval > 0) {
                const maxA = Math.max(...data.crack_size_mm);
                traces.push({
                    x: [inspectionInterval, inspectionInterval],
                    y: [data.crack_size_mm[0], maxA],
                    name: 'Inspection (N_f/3)',
                    type: 'scatter',
                    mode: 'lines',
                    line: { color: theme.warningColor, width: 2, dash: 'dash' }
                });
            }

            Plotly.newPlot('growth-plot', traces, {
                xaxis: { title: 'Cycles', gridcolor: theme.gridColor, color: theme.textColor },
                yaxis: { title: 'Crack Size (mm)', gridcolor: theme.gridColor, color: theme.textColor },
                legend: { x: 0.02, y: 0.98, font: { color: theme.textColor } },
                margin: { t: 20, r: 20 },
                paper_bgcolor: theme.bgColor,
                plot_bgcolor: theme.bgColor,
                font: { family: 'Helvetica Neue, sans-serif', color: theme.textColor }
            }, { responsive: true });
        }

        function plotKvsA(data) {
            if (!data || !data.crack_size_mm || data.crack_size_mm.length < 2) return;
            const theme = getChartTheme();

            const traces = [
                {
                    x: data.crack_size_mm,
                    y: data.K_I_mpa_sqrt_m,
                    name: 'K_I',
                    type: 'scatter',
                    mode: 'lines',
                    line: { color: theme.accentColor, width: 2 }
                },
                {
                    x: data.crack_size_mm,
                    y: data.K_IC_line,
                    name: 'K_IC',
                    type: 'scatter',
                    mode: 'lines',
                    line: { color: theme.dangerColor, width: 2, dash: 'dash' }
                }
            ];

            Plotly.newPlot('ki-plot', traces, {
                xaxis: { title: 'Crack Size (mm)', gridcolor: theme.gridColor, color: theme.textColor },
                yaxis: { title: 'K_I (MPa\u221Am)', gridcolor: theme.gridColor, color: theme.textColor },
                legend: { x: 0.02, y: 0.98, font: { color: theme.textColor } },
                margin: { t: 20, r: 20 },
                paper_bgcolor: theme.bgColor,
                plot_bgcolor: theme.bgColor,
                font: { family: 'Helvetica Neue, sans-serif', color: theme.textColor }
            }, { responsive: true });
        }

        // =================================================================
        // SENSITIVITY SWEEP
        // =================================================================
        const SWEEP_PARAMS = {
            initial_crack_size_mm: { label: 'Initial Crack Size (mm)', rangeFn: v => [Math.max(0.1, v * 0.1), v * 3], logSpace: false },
            speed_rpm:             { label: 'Speed (RPM)',             rangeFn: v => [v * 0.5, v * 1.5],              logSpace: false },
            stress_ratio_R:        { label: 'Stress Ratio (R)',        rangeFn: () => [0, 0.9],                       logSpace: false },
            fracture_toughness:    { label: 'Fracture Toughness K_IC', rangeFn: v => [v * 0.5, v * 2],               logSpace: false },
            paris_C:               { label: 'Paris C',                 rangeFn: v => [v * 0.1, v * 10],              logSpace: true },
            paris_m:               { label: 'Paris m',                 rangeFn: v => [Math.max(1, v - 1), v + 1],    logSpace: false },
            thickness_mm:          { label: 'Thickness (mm)',          rangeFn: v => [v * 0.5, v * 2],               logSpace: false },
            crack_location_radius_mm: {
                label: 'Crack Location Radius (mm)',
                rangeFn: () => {
                    const ri = parseFloat(document.getElementById('inner_radius_mm').value) || 0;
                    const ro = parseFloat(document.getElementById('outer_radius_mm').value);
                    return [Math.max(ri + 0.1, ri), ro];
                },
                logSpace: false
            },
            crack_aspect_ratio: { label: 'Crack Aspect Ratio (a/c)', rangeFn: v => [0.1, Math.max(v * 3, 3)], logSpace: false },
            // Categorical parameters
            crack_type: {
                label: 'Crack Type',
                categorical: true,
                options: [
                    { value: 'through', label: 'Through' },
                    { value: 'surface', label: 'Surface' },
                    { value: 'edge', label: 'Edge' },
                    { value: 'embedded', label: 'Embedded' },
                    { value: 'elliptical_surface', label: 'Elliptical Surface' },
                    { value: 'corner', label: 'Corner' },
                    { value: 'double_edge', label: 'Double Edge' }
                ],
                baselineKey: 'crack_t'
            },
            crack_orientation: {
                label: 'Crack Orientation',
                categorical: true,
                options: [
                    { value: 'radial', label: 'Radial' },
                    { value: 'circumferential', label: 'Circumferential' }
                ],
                baselineKey: 'crack_orient'
            },
            geometry_type: {
                label: 'Geometry Type',
                categorical: true,
                options: [
                    { value: 'hollow_disk', label: 'Hollow Disk' },
                    { value: 'solid_disk', label: 'Solid Disk' },
                    { value: 'hollow_cylinder', label: 'Hollow Cylinder' }
                ],
                baselineKey: 'geom'
            }
        };

        function onSweepParamChange() {
            const key = document.getElementById('sweep-param').value;
            const cfg = SWEEP_PARAMS[key];
            const numericControls = document.getElementById('sweep-numeric-controls');

            if (cfg.categorical) {
                numericControls.style.display = 'none';
            } else {
                numericControls.style.display = 'contents';
                const currentVal = parseFloat(document.getElementById(key).value);
                const [lo, hi] = cfg.rangeFn(currentVal);

                const precision = key === 'paris_C' ? 2 : (lo < 1 ? 3 : 1);
                document.getElementById('sweep-min').value = cfg.logSpace ? lo.toExponential(1) : parseFloat(lo.toFixed(precision));
                document.getElementById('sweep-max').value = cfg.logSpace ? hi.toExponential(1) : parseFloat(hi.toFixed(precision));
            }
        }

        function generateSweepValues(min, max, n, logSpace) {
            const vals = [];
            if (logSpace && min > 0 && max > 0) {
                const logMin = Math.log10(min);
                const logMax = Math.log10(max);
                for (let i = 0; i < n; i++) {
                    vals.push(Math.pow(10, logMin + (logMax - logMin) * i / (n - 1)));
                }
            } else {
                for (let i = 0; i < n; i++) {
                    vals.push(min + (max - min) * i / (n - 1));
                }
            }
            return vals;
        }

        function readBaseline() {
            return {
                geom: document.getElementById('geometry_type').value,
                inner_r: parseFloat(document.getElementById('inner_radius_mm').value) || 0,
                outer_r: parseFloat(document.getElementById('outer_radius_mm').value),
                speed: parseFloat(document.getElementById('speed_rpm').value),
                crack_loc: parseFloat(document.getElementById('crack_location_radius_mm').value),
                crack_size: parseFloat(document.getElementById('initial_crack_size_mm').value),
                crack_t: document.getElementById('crack_type').value,
                crack_orient: document.getElementById('crack_orientation').value,
                mat_preset: document.getElementById('material_preset').value,
                k_ic: parseFloat(document.getElementById('fracture_toughness').value),
                pC: parseFloat(document.getElementById('paris_C').value),
                pm: parseFloat(document.getElementById('paris_m').value),
                density: parseFloat(document.getElementById('density_kg_m3').value),
                poisson: parseFloat(document.getElementById('poisson_ratio').value),
                uts: parseFloat(document.getElementById('tensile_strength_mpa').value),
                R: parseFloat(document.getElementById('stress_ratio_R').value),
                design_life: parseFloat(document.getElementById('design_life_cycles').value),
                req_sf: parseFloat(document.getElementById('required_fracture_sf').value),
                thickness: parseFloat(document.getElementById('thickness_mm').value),
                crack_ar: parseFloat(document.getElementById('crack_aspect_ratio').value) || 1.0
            };
        }

        function runSweepCall(params) {
            const resultProxy = pyToolModule.analyze_fracture_and_crack_growth(
                params.geom, params.inner_r, params.outer_r, params.speed,
                params.crack_loc, params.crack_size, params.crack_t, params.crack_orient,
                params.mat_preset, params.k_ic, params.pC, params.pm,
                params.density, params.poisson, params.uts,
                params.R, params.design_life, params.req_sf, params.thickness,
                params.crack_ar
            );
            const r = resultProxy.toJs({ dict_converter: Object.fromEntries });
            resultProxy.destroy();
            return r;
        }

        async function runSensitivity() {
            if (!lastResults || !pyToolModule) return;

            const btn = document.getElementById('run-sweep-btn');
            btn.textContent = 'Running...';
            btn.disabled = true;

            const paramKey = document.getElementById('sweep-param').value;
            const cfg = SWEEP_PARAMS[paramKey];
            const baseline = readBaseline();

            // Fix #6: Force custom preset when sweeping K_IC, Paris C, or Paris m
            const presetOverrideParams = ['fracture_toughness', 'paris_C', 'paris_m'];
            if (presetOverrideParams.includes(paramKey) && baseline.mat_preset !== 'custom') {
                baseline.mat_preset = 'custom';
            }

            const progressDiv = document.getElementById('sweep-progress');
            const progressFill = document.getElementById('sweep-progress-fill');
            const progressText = document.getElementById('sweep-progress-text');
            progressDiv.style.display = 'block';
            progressFill.style.width = '0%';

            try {
                if (cfg.categorical) {
                    await runCategoricalSweep(cfg, baseline, progressFill, progressText);
                } else {
                    await runNumericSweep(paramKey, cfg, baseline, progressFill, progressText);
                }
                document.getElementById('sensitivity-plots').style.display = 'block';
            } finally {
                progressDiv.style.display = 'none';
                btn.textContent = 'Run Sweep';
                btn.disabled = false;
            }
        }

        async function runNumericSweep(paramKey, cfg, baseline, progressFill, progressText) {
            const sweepMin = parseFloat(document.getElementById('sweep-min').value);
            const sweepMax = parseFloat(document.getElementById('sweep-max').value);
            const steps = parseInt(document.getElementById('sweep-steps').value) || 20;
            const sweepValues = generateSweepValues(sweepMin, sweepMax, steps, cfg.logSpace);

            const paramMap = {
                initial_crack_size_mm: 'crack_size',
                speed_rpm: 'speed',
                stress_ratio_R: 'R',
                fracture_toughness: 'k_ic',
                paris_C: 'pC',
                paris_m: 'pm',
                thickness_mm: 'thickness',
                crack_location_radius_mm: 'crack_loc',
                crack_aspect_ratio: 'crack_ar'
            };
            const overrideKey = paramMap[paramKey];

            progressText.textContent = `0 / ${steps}`;

            const sfArr = [], nfArr = [], lifeArr = [];

            for (let i = 0; i < sweepValues.length; i++) {
                const params = { ...baseline };
                params[overrideKey] = sweepValues[i];

                try {
                    const r = runSweepCall(params);
                    sfArr.push(r.fracture_safety_factor);
                    nfArr.push(r.cycles_to_failure);
                    lifeArr.push(r.life_fraction_used);
                } catch (e) {
                    sfArr.push(NaN);
                    nfArr.push(NaN);
                    lifeArr.push(NaN);
                }

                const pct = ((i + 1) / steps * 100).toFixed(0);
                progressFill.style.width = pct + '%';
                progressText.textContent = `${i + 1} / ${steps}`;
                if (i % 3 === 0) await new Promise(r => setTimeout(r, 0));
            }

            const currentVal = parseFloat(document.getElementById(paramKey).value);
            plotSensitivity(sweepValues, sfArr, nfArr, lifeArr, cfg, currentVal, baseline.req_sf, baseline.design_life);
        }

        async function runCategoricalSweep(cfg, baseline, progressFill, progressText) {
            const options = cfg.options;
            const overrideKey = cfg.baselineKey;
            const currentVal = baseline[overrideKey];

            progressText.textContent = `0 / ${options.length}`;

            const labels = [], sfArr = [], nfArr = [], lifeArr = [], errors = [];

            for (let i = 0; i < options.length; i++) {
                const opt = options[i];
                const params = { ...baseline };
                params[overrideKey] = opt.value;

                labels.push(opt.label);
                try {
                    const r = runSweepCall(params);
                    sfArr.push(r.fracture_safety_factor);
                    nfArr.push(r.cycles_to_failure);
                    lifeArr.push(r.life_fraction_used);
                    errors.push(null);
                } catch (e) {
                    sfArr.push(NaN);
                    nfArr.push(NaN);
                    lifeArr.push(NaN);
                    errors.push(e.message || String(e));
                }

                const pct = ((i + 1) / options.length * 100).toFixed(0);
                progressFill.style.width = pct + '%';
                progressText.textContent = `${i + 1} / ${options.length}`;
                await new Promise(r => setTimeout(r, 0));
            }

            // Find the index of the current baseline value
            const currentIdx = options.findIndex(o => o.value === currentVal);

            plotCategoricalSensitivity(labels, sfArr, nfArr, lifeArr, errors, cfg, currentIdx, baseline.req_sf, baseline.design_life);
        }

        function plotSensitivity(xVals, sfArr, nfArr, lifeArr, cfg, currentVal, reqSF, designLife) {
            const theme = getChartTheme();
            const xAxisType = cfg.logSpace ? 'log' : 'linear';
            const xLabel = cfg.label;

            const baselineVLine = (yRange) => ({
                x: [currentVal, currentVal],
                y: yRange,
                mode: 'lines',
                line: { color: theme.accentColor, width: 1.5, dash: 'dash' },
                name: 'Current',
                showlegend: false,
                hoverinfo: 'skip'
            });

            const layoutBase = {
                paper_bgcolor: theme.bgColor,
                plot_bgcolor: theme.bgColor,
                font: { family: 'Helvetica Neue, sans-serif', color: theme.textColor },
                margin: { t: 10, r: 20, b: 44, l: 60 },
                legend: { x: 0.02, y: 0.98, font: { color: theme.textColor, size: 11 } }
            };

            // --- Plot 1: Fracture Safety Factor ---
            const sfMax = Math.max(...sfArr.filter(Number.isFinite), reqSF * 1.5);
            Plotly.newPlot('sensitivity-sf-plot', [
                { x: xVals, y: sfArr, mode: 'lines+markers', name: 'Fracture SF',
                  line: { color: '#3b82f6', width: 2 }, marker: { size: 4 } },
                baselineVLine([0, sfMax]),
                { x: [xVals[0], xVals[xVals.length - 1]], y: [reqSF, reqSF], mode: 'lines',
                  line: { color: theme.dangerColor, width: 1.5, dash: 'dot' }, name: 'Required SF' }
            ], {
                ...layoutBase,
                xaxis: { title: xLabel, type: xAxisType, gridcolor: theme.gridColor, color: theme.textColor },
                yaxis: { title: 'Safety Factor', gridcolor: theme.gridColor, color: theme.textColor, rangemode: 'tozero' }
            }, { responsive: true });

            // --- Plot 2: Cycles to Failure (log y) ---
            const nfFinite = nfArr.filter(Number.isFinite);
            const nfMin = nfFinite.length ? Math.min(...nfFinite) : 1;
            const nfMax = nfFinite.length ? Math.max(...nfFinite) : 1e7;
            const yRangeNf = [Math.max(1, nfMin * 0.5), nfMax * 2];
            Plotly.newPlot('sensitivity-nf-plot', [
                { x: xVals, y: nfArr, mode: 'lines+markers', name: 'Cycles to Failure',
                  line: { color: '#3b82f6', width: 2 }, marker: { size: 4 } },
                baselineVLine(yRangeNf),
                { x: [xVals[0], xVals[xVals.length - 1]], y: [designLife, designLife], mode: 'lines',
                  line: { color: theme.dangerColor, width: 1.5, dash: 'dot' }, name: 'Design Life' }
            ], {
                ...layoutBase,
                xaxis: { title: xLabel, type: xAxisType, gridcolor: theme.gridColor, color: theme.textColor },
                yaxis: { title: 'Cycles to Failure', type: 'log', gridcolor: theme.gridColor, color: theme.textColor }
            }, { responsive: true });

            // --- Plot 3: Life Fraction Used ---
            const lifeMax = Math.max(...lifeArr.filter(Number.isFinite), 1.5);
            Plotly.newPlot('sensitivity-life-plot', [
                { x: xVals, y: lifeArr, mode: 'lines+markers', name: 'Life Fraction',
                  line: { color: '#3b82f6', width: 2 }, marker: { size: 4 } },
                baselineVLine([0, lifeMax]),
                { x: [xVals[0], xVals[xVals.length - 1]], y: [1.0, 1.0], mode: 'lines',
                  line: { color: theme.dangerColor, width: 1.5, dash: 'dot' }, name: '100% Life' }
            ], {
                ...layoutBase,
                xaxis: { title: xLabel, type: xAxisType, gridcolor: theme.gridColor, color: theme.textColor },
                yaxis: { title: 'Life Fraction', gridcolor: theme.gridColor, color: theme.textColor, rangemode: 'tozero' }
            }, { responsive: true });
        }

        function plotCategoricalSensitivity(labels, sfArr, nfArr, lifeArr, errors, cfg, currentIdx, reqSF, designLife) {
            const theme = getChartTheme();

            // Color each bar: highlight current baseline, grey out errors
            const barColors = labels.map((_, i) => {
                if (errors[i]) return theme.gridColor;
                if (i === currentIdx) return theme.accentColor;
                return '#3b82f6';
            });

            const hoverText = labels.map((lbl, i) =>
                errors[i] ? `${lbl}<br><i>Error: ${errors[i].substring(0, 60)}</i>` : lbl
            );

            const layoutBase = {
                paper_bgcolor: theme.bgColor,
                plot_bgcolor: theme.bgColor,
                font: { family: 'Helvetica Neue, sans-serif', color: theme.textColor },
                margin: { t: 10, r: 20, b: 80, l: 60 },
                bargap: 0.25
            };

            // --- Plot 1: Fracture Safety Factor ---
            Plotly.newPlot('sensitivity-sf-plot', [
                { x: labels, y: sfArr, type: 'bar', marker: { color: barColors },
                  text: sfArr.map(v => isFinite(v) ? v.toFixed(2) : ''), textposition: 'outside',
                  hovertext: hoverText, hoverinfo: 'text+y' },
                { x: [labels[0], labels[labels.length - 1]], y: [reqSF, reqSF], mode: 'lines',
                  line: { color: theme.dangerColor, width: 1.5, dash: 'dot' }, name: 'Required SF', showlegend: true }
            ], {
                ...layoutBase,
                xaxis: { title: cfg.label, tickangle: -30, gridcolor: theme.gridColor, color: theme.textColor },
                yaxis: { title: 'Safety Factor', gridcolor: theme.gridColor, color: theme.textColor, rangemode: 'tozero' }
            }, { responsive: true });

            // --- Plot 2: Cycles to Failure (log y) ---
            Plotly.newPlot('sensitivity-nf-plot', [
                { x: labels, y: nfArr, type: 'bar', marker: { color: barColors },
                  text: nfArr.map(v => isFinite(v) ? v.toExponential(1) : ''), textposition: 'outside',
                  hovertext: hoverText, hoverinfo: 'text+y' },
                { x: [labels[0], labels[labels.length - 1]], y: [designLife, designLife], mode: 'lines',
                  line: { color: theme.dangerColor, width: 1.5, dash: 'dot' }, name: 'Design Life', showlegend: true }
            ], {
                ...layoutBase,
                xaxis: { title: cfg.label, tickangle: -30, gridcolor: theme.gridColor, color: theme.textColor },
                yaxis: { title: 'Cycles to Failure', type: 'log', gridcolor: theme.gridColor, color: theme.textColor }
            }, { responsive: true });

            // --- Plot 3: Life Fraction Used ---
            Plotly.newPlot('sensitivity-life-plot', [
                { x: labels, y: lifeArr, type: 'bar', marker: { color: barColors },
                  text: lifeArr.map(v => isFinite(v) ? v.toFixed(3) : ''), textposition: 'outside',
                  hovertext: hoverText, hoverinfo: 'text+y' },
                { x: [labels[0], labels[labels.length - 1]], y: [1.0, 1.0], mode: 'lines',
                  line: { color: theme.dangerColor, width: 1.5, dash: 'dot' }, name: '100% Life', showlegend: true }
            ], {
                ...layoutBase,
                xaxis: { title: cfg.label, tickangle: -30, gridcolor: theme.gridColor, color: theme.textColor },
                yaxis: { title: 'Life Fraction', gridcolor: theme.gridColor, color: theme.textColor, rangemode: 'tozero' }
            }, { responsive: true });
        }
    </script>
</body>
</html>
